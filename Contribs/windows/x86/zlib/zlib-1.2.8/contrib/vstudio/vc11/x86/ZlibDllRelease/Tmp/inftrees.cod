; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Trunk2012\Contribs\windows\x86\zlib\zlib-1.2.8\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	048H
	DW	04eH
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
_inflate_copyright DB ' inflate 1.2.8 Copyright 1995-2013 Mark Adler ', 00H
	ORG $+1
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	_inflate_table
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
_offs$ = -128						; size = 32
_count$ = -96						; size = 32
_min$2$ = -64						; size = 4
_mask$1$ = -60						; size = 4
tv1270 = -56						; size = 4
tv1265 = -56						; size = 4
_low$1$ = -52						; size = 4
_lens$1$ = -48						; size = 4
_used$1$ = -44						; size = 4
_type$1$ = -40						; size = 4
tv1271 = -36						; size = 4
_base$1$ = -32						; size = 4
_extra$1$ = -28						; size = 4
_end$1$ = -24						; size = 4
_root$3$ = -20						; size = 4
_len$2$ = -16						; size = 4
_huff$1$ = -12						; size = 4
_next$1$ = -8						; size = 4
_drop$1$ = -4						; size = 4
_here$ = 8						; size = 4
_codes$ = 8						; size = 4
_table$ = 12						; size = 4
_bits$ = 16						; size = 4
_work$ = 20						; size = 4
_inflate_table PROC					; COMDAT
; _type$ = ecx
; _lens$ = edx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  0000b	33 f6		 xor	 esi, esi
  0000d	0f b7 c6	 movzx	 eax, si
  00010	8b f0		 mov	 esi, eax
  00012	c1 e0 10	 shl	 eax, 16			; 00000010H
  00015	0b f0		 or	 esi, eax
  00017	89 75 a0	 mov	 DWORD PTR _count$[ebp], esi
  0001a	89 75 a4	 mov	 DWORD PTR _count$[ebp+4], esi
  0001d	89 75 a8	 mov	 DWORD PTR _count$[ebp+8], esi
  00020	89 75 ac	 mov	 DWORD PTR _count$[ebp+12], esi
  00023	89 75 b0	 mov	 DWORD PTR _count$[ebp+16], esi
  00026	89 75 b4	 mov	 DWORD PTR _count$[ebp+20], esi
  00029	89 75 b8	 mov	 DWORD PTR _count$[ebp+24], esi
  0002c	89 75 bc	 mov	 DWORD PTR _count$[ebp+28], esi

; 109  :     for (sym = 0; sym < codes; sym++)

  0002f	8b 75 08	 mov	 esi, DWORD PTR _codes$[ebp]
  00032	89 4d d8	 mov	 DWORD PTR _type$1$[ebp], ecx
  00035	33 c9		 xor	 ecx, ecx
  00037	57		 push	 edi
  00038	89 55 d0	 mov	 DWORD PTR _lens$1$[ebp], edx
  0003b	85 f6		 test	 esi, esi
  0003d	74 0f		 je	 SHORT $LN57@inflate_ta
  0003f	90		 npad	 1
$LL59@inflate_ta:

; 110  :         count[lens[sym]]++;

  00040	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00044	41		 inc	 ecx
  00045	66 ff 44 45 a0	 inc	 WORD PTR _count$[ebp+eax*2]
  0004a	3b ce		 cmp	 ecx, esi
  0004c	72 f2		 jb	 SHORT $LL59@inflate_ta
$LN57@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  0004e	8b 5d 10	 mov	 ebx, DWORD PTR _bits$[ebp]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00051	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  00056	8b 03		 mov	 eax, DWORD PTR [ebx]
$LL56@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00058	66 83 7c 7d a0
	00		 cmp	 WORD PTR _count$[ebp+edi*2], 0
  0005e	75 06		 jne	 SHORT $LN77@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00060	4f		 dec	 edi
  00061	83 ff 01	 cmp	 edi, 1
  00064	73 f2		 jae	 SHORT $LL56@inflate_ta
$LN77@inflate_ta:

; 116  :     if (root > max) root = max;

  00066	3b c7		 cmp	 eax, edi
  00068	0f 47 c7	 cmova	 eax, edi

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0006b	85 ff		 test	 edi, edi
  0006d	75 2a		 jne	 SHORT $LN51@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  0006f	8b 55 0c	 mov	 edx, DWORD PTR _table$[ebp]
  00072	c7 45 08 40 01
	00 00		 mov	 DWORD PTR _here$[ebp], 320 ; 00000140H
  00079	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0007b	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
  0007e	89 01		 mov	 DWORD PTR [ecx], eax
  00080	83 02 04	 add	 DWORD PTR [edx], 4
  00083	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00085	5f		 pop	 edi

; 122  :         *(*table)++ = here;

  00086	89 01		 mov	 DWORD PTR [ecx], eax
  00088	83 02 04	 add	 DWORD PTR [edx], 4
  0008b	5e		 pop	 esi

; 123  :         *bits = 1;

  0008c	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00092	33 c0		 xor	 eax, eax
  00094	5b		 pop	 ebx

; 306  : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN51@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00099	bb 01 00 00 00	 mov	 ebx, 1
  0009e	89 5d f0	 mov	 DWORD PTR _len$2$[ebp], ebx
  000a1	3b fb		 cmp	 edi, ebx
  000a3	76 10		 jbe	 SHORT $LN78@inflate_ta
$LL50@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000a5	66 83 7c 5d a0
	00		 cmp	 WORD PTR _count$[ebp+ebx*2], 0
  000ab	75 05		 jne	 SHORT $LN116@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000ad	43		 inc	 ebx
  000ae	3b df		 cmp	 ebx, edi
  000b0	72 f3		 jb	 SHORT $LL50@inflate_ta
$LN116@inflate_ta:
  000b2	89 5d f0	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN78@inflate_ta:

; 128  :     if (root < min) root = min;

  000b5	3b c3		 cmp	 eax, ebx
  000b7	0f 42 c3	 cmovb	 eax, ebx

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000ba	ba 01 00 00 00	 mov	 edx, 1
  000bf	89 45 ec	 mov	 DWORD PTR _root$3$[ebp], eax

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000c2	8b ca		 mov	 ecx, edx
$LL45@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  000c4	0f b7 44 4d a0	 movzx	 eax, WORD PTR _count$[ebp+ecx*2]
  000c9	03 d2		 add	 edx, edx
  000cb	2b d0		 sub	 edx, eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  000cd	0f 88 ee 02 00
	00		 js	 $LN79@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000d3	41		 inc	 ecx
  000d4	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000d7	76 eb		 jbe	 SHORT $LL45@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  000d9	85 d2		 test	 edx, edx
  000db	7e 13		 jle	 SHORT $LN41@inflate_ta
  000dd	83 7d d8 00	 cmp	 DWORD PTR _type$1$[ebp], 0
  000e1	0f 84 da 02 00
	00		 je	 $LN79@inflate_ta
  000e7	83 ff 01	 cmp	 edi, 1
  000ea	0f 85 d1 02 00
	00		 jne	 $LN79@inflate_ta
$LN41@inflate_ta:

; 138  :         return -1;                      /* incomplete set */
; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  000f0	33 c0		 xor	 eax, eax
  000f2	66 89 45 82	 mov	 WORD PTR _offs$[ebp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  000f6	b9 02 00 00 00	 mov	 ecx, 2
  000fb	eb 03 8d 49 00	 npad	 5
$LL91@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00100	66 8b 44 0d 80	 mov	 ax, WORD PTR _offs$[ebp+ecx]
  00105	66 03 44 0d a0	 add	 ax, WORD PTR _count$[ebp+ecx]
  0010a	83 c1 02	 add	 ecx, 2
  0010d	66 89 44 0d 80	 mov	 WORD PTR _offs$[ebp+ecx], ax
  00112	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00115	72 e9		 jb	 SHORT $LL91@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00117	33 c9		 xor	 ecx, ecx
  00119	85 f6		 test	 esi, esi
  0011b	74 29		 je	 SHORT $LN34@inflate_ta
  0011d	8b 55 14	 mov	 edx, DWORD PTR _work$[ebp]
  00120	8b 5d d0	 mov	 ebx, DWORD PTR _lens$1$[ebp]
$LL36@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00123	0f b7 04 4b	 movzx	 eax, WORD PTR [ebx+ecx*2]
  00127	66 85 c0	 test	 ax, ax
  0012a	74 12		 je	 SHORT $LN35@inflate_ta
  0012c	0f b7 44 45 80	 movzx	 eax, WORD PTR _offs$[ebp+eax*2]
  00131	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00135	0f b7 04 4b	 movzx	 eax, WORD PTR [ebx+ecx*2]
  00139	66 ff 44 45 80	 inc	 WORD PTR _offs$[ebp+eax*2]
$LN35@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0013e	41		 inc	 ecx
  0013f	3b ce		 cmp	 ecx, esi
  00141	72 e0		 jb	 SHORT $LL36@inflate_ta
  00143	8b 5d f0	 mov	 ebx, DWORD PTR _len$2$[ebp]
$LN34@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00146	8b 75 d8	 mov	 esi, DWORD PTR _type$1$[ebp]
  00149	8b c6		 mov	 eax, esi
  0014b	83 e8 00	 sub	 eax, 0
  0014e	74 3d		 je	 SHORT $LN30@inflate_ta
  00150	48		 dec	 eax
  00151	74 16		 je	 SHORT $LN29@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;
; 195  :         extra = dext;
; 196  :         end = -1;

  00153	83 c8 ff	 or	 eax, -1
  00156	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9
  0015d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _extra$1$[ebp], OFFSET ?dext@?1??inflate_table@@9@9
  00164	89 45 e8	 mov	 DWORD PTR _end$1$[ebp], eax
  00167	eb 34		 jmp	 SHORT $LN31@inflate_ta
$LN29@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  00169	b8 00 00 00 00	 mov	 eax, OFFSET ?lbase@?1??inflate_table@@9@9
  0016e	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  00173	89 45 e0	 mov	 DWORD PTR _base$1$[ebp], eax

; 189  :         extra = lext;
; 190  :         extra -= 257;

  00176	b8 00 00 00 00	 mov	 eax, OFFSET ?lext@?1??inflate_table@@9@9
  0017b	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  00180	89 45 e4	 mov	 DWORD PTR _extra$1$[ebp], eax

; 191  :         end = 256;

  00183	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00188	89 45 e8	 mov	 DWORD PTR _end$1$[ebp], eax

; 192  :         break;

  0018b	eb 10		 jmp	 SHORT $LN31@inflate_ta
$LN30@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  0018d	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]
  00190	89 45 e4	 mov	 DWORD PTR _extra$1$[ebp], eax
  00193	89 45 e0	 mov	 DWORD PTR _base$1$[ebp], eax

; 184  :         end = 19;

  00196	c7 45 e8 13 00
	00 00		 mov	 DWORD PTR _end$1$[ebp], 19 ; 00000013H
$LN31@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _table$[ebp]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */
; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */

  001a0	ba 01 00 00 00	 mov	 edx, 1
  001a5	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a7	8b 4d ec	 mov	 ecx, DWORD PTR _root$3$[ebp]
  001aa	d3 e2		 shl	 edx, cl
  001ac	89 45 f8	 mov	 DWORD PTR _next$1$[ebp], eax
  001af	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _huff$1$[ebp], 0
  001b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _drop$1$[ebp], 0
  001bd	8b c2		 mov	 eax, edx
  001bf	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _low$1$[ebp], -1

; 208  :     mask = used - 1;            /* mask for comparing low */

  001c6	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  001c9	89 55 dc	 mov	 DWORD PTR tv1271[ebp], edx
  001cc	89 45 d4	 mov	 DWORD PTR _used$1$[ebp], eax
  001cf	89 4d c4	 mov	 DWORD PTR _mask$1$[ebp], ecx

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used > ENOUGH_LENS) ||
; 212  :         (type == DISTS && used > ENOUGH_DISTS))

  001d2	83 fe 01	 cmp	 esi, 1
  001d5	75 09		 jne	 SHORT $LN25@inflate_ta
  001d7	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  001dc	77 0e		 ja	 SHORT $LN26@inflate_ta
  001de	eb 20		 jmp	 SHORT $LL24@inflate_ta
$LN25@inflate_ta:
  001e0	83 fe 02	 cmp	 esi, 2
  001e3	75 1b		 jne	 SHORT $LL24@inflate_ta
  001e5	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  001ea	76 14		 jbe	 SHORT $LL24@inflate_ta
$LN26@inflate_ta:
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi

; 213  :         return 1;

  001ee	b8 01 00 00 00	 mov	 eax, 1
  001f3	5b		 pop	 ebx

; 306  : }

  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
$LL118@inflate_ta:
  001f8	8b 55 dc	 mov	 edx, DWORD PTR tv1271[ebp]
  001fb	eb 03 8d 49 00	 npad	 5
$LL24@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);
; 219  :         if ((int)(work[sym]) < end) {

  00200	8b 75 e8	 mov	 esi, DWORD PTR _end$1$[ebp]
  00203	8a c3		 mov	 al, bl
  00205	2a 45 fc	 sub	 al, BYTE PTR _drop$1$[ebp]
  00208	88 45 09	 mov	 BYTE PTR _here$[ebp+1], al
  0020b	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]
  0020e	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00211	8b c8		 mov	 ecx, eax
  00213	3b ce		 cmp	 ecx, esi
  00215	7d 06		 jge	 SHORT $LN123@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00217	c6 45 08 00	 mov	 BYTE PTR _here$[ebp], 0

; 221  :             here.val = work[sym];

  0021b	eb 1a		 jmp	 SHORT $LN124@inflate_ta
$LN123@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  0021d	7e 12		 jle	 SHORT $LN20@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  0021f	8b 45 e4	 mov	 eax, DWORD PTR _extra$1$[ebp]
  00222	8a 04 48	 mov	 al, BYTE PTR [eax+ecx*2]
  00225	88 45 08	 mov	 BYTE PTR _here$[ebp], al

; 225  :             here.val = base[work[sym]];

  00228	8b 45 e0	 mov	 eax, DWORD PTR _base$1$[ebp]
  0022b	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]

; 226  :         }
; 227  :         else {

  0022f	eb 06		 jmp	 SHORT $LN124@inflate_ta
$LN20@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00231	c6 45 08 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 229  :             here.val = 0;

  00235	33 c0		 xor	 eax, eax
$LN124@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00237	8b cb		 mov	 ecx, ebx
  00239	2b 4d fc	 sub	 ecx, DWORD PTR _drop$1$[ebp]
  0023c	be 01 00 00 00	 mov	 esi, 1
  00241	d3 e6		 shl	 esi, cl
  00243	8b 4d fc	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  00246	66 89 45 0a	 mov	 WORD PTR _here$[ebp+2], ax

; 234  :         fill = 1U << curr;
; 235  :         min = fill;                 /* save offset to next table */

  0024a	89 55 c0	 mov	 DWORD PTR _min$2$[ebp], edx
  0024d	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  00254	89 45 c8	 mov	 DWORD PTR tv1265[ebp], eax
  00257	8b 45 f4	 mov	 eax, DWORD PTR _huff$1$[ebp]
  0025a	d3 e8		 shr	 eax, cl
  0025c	8b 4d f8	 mov	 ecx, DWORD PTR _next$1$[ebp]
  0025f	03 c2		 add	 eax, edx
  00261	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00264	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
$LL18@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  00267	2b 4d c8	 sub	 ecx, DWORD PTR tv1265[ebp]

; 238  :             next[(huff >> drop) + fill] = here;

  0026a	89 01		 mov	 DWORD PTR [ecx], eax
  0026c	2b d6		 sub	 edx, esi

; 239  :         } while (fill != 0);

  0026e	75 f7		 jne	 SHORT $LL18@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  00270	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00273	ba 01 00 00 00	 mov	 edx, 1
  00278	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  0027a	8b 4d f4	 mov	 ecx, DWORD PTR _huff$1$[ebp]
  0027d	85 d1		 test	 edx, ecx
  0027f	74 06		 je	 SHORT $LN14@inflate_ta
$LL15@inflate_ta:

; 244  :             incr >>= 1;

  00281	d1 ea		 shr	 edx, 1
  00283	85 d1		 test	 edx, ecx
  00285	75 fa		 jne	 SHORT $LL15@inflate_ta
$LN14@inflate_ta:

; 245  :         if (incr != 0) {

  00287	85 d2		 test	 edx, edx
  00289	74 09		 je	 SHORT $LN13@inflate_ta

; 246  :             huff &= incr - 1;

  0028b	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0028e	23 c1		 and	 eax, ecx

; 247  :             huff += incr;

  00290	03 d0		 add	 edx, eax

; 248  :         }
; 249  :         else

  00292	eb 02		 jmp	 SHORT $LN125@inflate_ta
$LN13@inflate_ta:

; 250  :             huff = 0;

  00294	33 d2		 xor	 edx, edx
$LN125@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  00296	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]
  00299	83 c0 02	 add	 eax, 2

; 254  :         if (--(count[len]) == 0) {

  0029c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002a1	66 01 4c 5d a0	 add	 WORD PTR _count$[ebp+ebx*2], cx
  002a6	89 55 f4	 mov	 DWORD PTR _huff$1$[ebp], edx
  002a9	89 45 14	 mov	 DWORD PTR _work$[ebp], eax
  002ac	75 15		 jne	 SHORT $LN11@inflate_ta

; 255  :             if (len == max) break;

  002ae	3b df		 cmp	 ebx, edi
  002b0	0f 84 d2 00 00
	00		 je	 $LN81@inflate_ta

; 256  :             len = lens[work[sym]];

  002b6	0f b7 00	 movzx	 eax, WORD PTR [eax]
  002b9	8b 4d d0	 mov	 ecx, DWORD PTR _lens$1$[ebp]
  002bc	0f b7 1c 41	 movzx	 ebx, WORD PTR [ecx+eax*2]
  002c0	89 5d f0	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN11@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  002c3	8b 45 ec	 mov	 eax, DWORD PTR _root$3$[ebp]
  002c6	3b d8		 cmp	 ebx, eax
  002c8	0f 86 2a ff ff
	ff		 jbe	 $LL118@inflate_ta
  002ce	8b 75 c4	 mov	 esi, DWORD PTR _mask$1$[ebp]
  002d1	23 f2		 and	 esi, edx
  002d3	8b 55 dc	 mov	 edx, DWORD PTR tv1271[ebp]
  002d6	89 75 c8	 mov	 DWORD PTR tv1270[ebp], esi
  002d9	3b 75 cc	 cmp	 esi, DWORD PTR _low$1$[ebp]
  002dc	0f 84 1e ff ff
	ff		 je	 $LL24@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  002e2	8b 55 fc	 mov	 edx, DWORD PTR _drop$1$[ebp]

; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  002e5	8b 4d f8	 mov	 ecx, DWORD PTR _next$1$[ebp]
  002e8	85 d2		 test	 edx, edx
  002ea	0f 44 d0	 cmove	 edx, eax
  002ed	8b 45 c0	 mov	 eax, DWORD PTR _min$2$[ebp]

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  002f0	2b da		 sub	 ebx, edx
  002f2	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  002f5	89 4d f8	 mov	 DWORD PTR _next$1$[ebp], ecx
  002f8	89 55 fc	 mov	 DWORD PTR _drop$1$[ebp], edx

; 270  :             left = (int)(1 << curr);

  002fb	b8 01 00 00 00	 mov	 eax, 1
  00300	8b cb		 mov	 ecx, ebx

; 271  :             while (curr + drop < max) {

  00302	03 d3		 add	 edx, ebx
  00304	d3 e0		 shl	 eax, cl
  00306	3b d7		 cmp	 edx, edi
  00308	73 1d		 jae	 SHORT $LN80@inflate_ta

; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0030a	8d 75 a0	 lea	 esi, DWORD PTR _count$[ebp]
  0030d	8d 34 56	 lea	 esi, DWORD PTR [esi+edx*2]
$LL7@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00310	0f b7 0e	 movzx	 ecx, WORD PTR [esi]
  00313	2b c1		 sub	 eax, ecx

; 273  :                 if (left <= 0) break;

  00315	85 c0		 test	 eax, eax
  00317	7e 0b		 jle	 SHORT $LN117@inflate_ta

; 274  :                 curr++;

  00319	42		 inc	 edx
  0031a	43		 inc	 ebx
  0031b	83 c6 02	 add	 esi, 2

; 275  :                 left <<= 1;

  0031e	03 c0		 add	 eax, eax
  00320	3b d7		 cmp	 edx, edi
  00322	72 ec		 jb	 SHORT $LL7@inflate_ta
$LN117@inflate_ta:
  00324	8b 75 c8	 mov	 esi, DWORD PTR tv1270[ebp]
$LN80@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  00327	8b 45 d4	 mov	 eax, DWORD PTR _used$1$[ebp]
  0032a	8b cb		 mov	 ecx, ebx
  0032c	ba 01 00 00 00	 mov	 edx, 1
  00331	d3 e2		 shl	 edx, cl

; 280  :             if ((type == LENS && used > ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used > ENOUGH_DISTS))

  00333	8b 4d d8	 mov	 ecx, DWORD PTR _type$1$[ebp]
  00336	03 c2		 add	 eax, edx
  00338	89 55 dc	 mov	 DWORD PTR tv1271[ebp], edx
  0033b	89 45 d4	 mov	 DWORD PTR _used$1$[ebp], eax
  0033e	83 f9 01	 cmp	 ecx, 1
  00341	75 07		 jne	 SHORT $LN2@inflate_ta
  00343	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  00348	eb 0a		 jmp	 SHORT $LN126@inflate_ta
$LN2@inflate_ta:
  0034a	83 f9 02	 cmp	 ecx, 2
  0034d	75 0b		 jne	 SHORT $LN4@inflate_ta
  0034f	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
$LN126@inflate_ta:
  00354	0f 87 92 fe ff
	ff		 ja	 $LN26@inflate_ta
$LN4@inflate_ta:

; 282  :                 return 1;
; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;
; 286  :             (*table)[low].op = (unsigned char)curr;

  0035a	8b 4d 0c	 mov	 ecx, DWORD PTR _table$[ebp]
  0035d	89 75 cc	 mov	 DWORD PTR _low$1$[ebp], esi
  00360	8b 01		 mov	 eax, DWORD PTR [ecx]
  00362	88 1c b0	 mov	 BYTE PTR [eax+esi*4], bl

; 287  :             (*table)[low].bits = (unsigned char)root;

  00365	8b 01		 mov	 eax, DWORD PTR [ecx]
  00367	8b 4d ec	 mov	 ecx, DWORD PTR _root$3$[ebp]

; 288  :             (*table)[low].val = (unsigned short)(next - *table);
; 289  :         }
; 290  :     }

  0036a	8b 5d f0	 mov	 ebx, DWORD PTR _len$2$[ebp]
  0036d	88 4c b0 01	 mov	 BYTE PTR [eax+esi*4+1], cl
  00371	8b 4d 0c	 mov	 ecx, DWORD PTR _table$[ebp]
  00374	8b 45 f8	 mov	 eax, DWORD PTR _next$1$[ebp]
  00377	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00379	2b c1		 sub	 eax, ecx
  0037b	c1 f8 02	 sar	 eax, 2
  0037e	66 89 44 b1 02	 mov	 WORD PTR [ecx+esi*4+2], ax
  00383	e9 78 fe ff ff	 jmp	 $LL24@inflate_ta
$LN81@inflate_ta:

; 291  : 
; 292  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 293  :        at most one remaining entry, since if the code is incomplete, the
; 294  :        maximum code length that was allowed to get this far is one bit) */
; 295  :     if (huff != 0) {

  00388	85 d2		 test	 edx, edx
  0038a	74 19		 je	 SHORT $LN1@inflate_ta

; 296  :         here.op = (unsigned char)64;            /* invalid code marker */
; 297  :         here.bits = (unsigned char)(len - drop);

  0038c	2a 5d fc	 sub	 bl, BYTE PTR _drop$1$[ebp]

; 298  :         here.val = (unsigned short)0;
; 299  :         next[huff] = here;

  0038f	8b 4d f8	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00392	33 c0		 xor	 eax, eax
  00394	c6 45 08 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H
  00398	88 5d 09	 mov	 BYTE PTR _here$[ebp+1], bl
  0039b	66 89 45 0a	 mov	 WORD PTR _here$[ebp+2], ax
  0039f	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
  003a2	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$LN1@inflate_ta:

; 300  :     }
; 301  : 
; 302  :     /* set return parameters */
; 303  :     *table += used;

  003a5	8b 45 d4	 mov	 eax, DWORD PTR _used$1$[ebp]
  003a8	8b 4d 0c	 mov	 ecx, DWORD PTR _table$[ebp]
  003ab	c1 e0 02	 shl	 eax, 2
  003ae	01 01		 add	 DWORD PTR [ecx], eax

; 304  :     *bits = root;

  003b0	8b 45 ec	 mov	 eax, DWORD PTR _root$3$[ebp]
  003b3	8b 4d 10	 mov	 ecx, DWORD PTR _bits$[ebp]
  003b6	5f		 pop	 edi
  003b7	5e		 pop	 esi
  003b8	89 01		 mov	 DWORD PTR [ecx], eax

; 305  :     return 0;

  003ba	33 c0		 xor	 eax, eax
  003bc	5b		 pop	 ebx

; 306  : }

  003bd	8b e5		 mov	 esp, ebp
  003bf	5d		 pop	 ebp
  003c0	c3		 ret	 0
$LN79@inflate_ta:
  003c1	5f		 pop	 edi
  003c2	5e		 pop	 esi

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  003c3	83 c8 ff	 or	 eax, -1
  003c6	5b		 pop	 ebx

; 306  : }

  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	c3		 ret	 0
_inflate_table ENDP
_TEXT	ENDS
END
