; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Trunk2012\Contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+2
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	_inflateMark@4
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
PUBLIC	_inflate@8
PUBLIC	_inflateEnd@4
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 3a		 je	 SHORT $LN2@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 33		 je	 SHORT $LN2@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2c		 je	 SHORT $LN2@inflateEnd

; 1260 :     state = (struct inflate_state FAR *)strm->state;
; 1261 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN1@inflateEnd
  00020	50		 push	 eax
  00021	ff 76 28	 push	 DWORD PTR [esi+40]
  00024	ff d1		 call	 ecx
  00026	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1262 :     ZFREE(strm, strm->state);

  00029	ff 76 1c	 push	 DWORD PTR [esi+28]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff 76 28	 push	 DWORD PTR [esi+40]
  00032	ff d0		 call	 eax
  00034	83 c4 08	 add	 esp, 8

; 1263 :     strm->state = Z_NULL;

  00037	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1264 :     Tracev((stderr, "inflate: end\n"));
; 1265 :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 1266 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1259 :         return Z_STREAM_ERROR;

  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	5e		 pop	 esi

; 1266 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
_copy$9$ = -52						; size = 4
tv2861 = -52						; size = 4
tv2811 = -52						; size = 4
tv2810 = -52						; size = 4
tv2804 = -52						; size = 4
tv2790 = -52						; size = 4
tv2783 = -52						; size = 4
tv2782 = -52						; size = 4
tv2772 = -52						; size = 4
tv2758 = -52						; size = 4
tv2757 = -52						; size = 4
tv2755 = -52						; size = 4
tv2716 = -52						; size = 4
_copy$7$ = -52						; size = 4
_copy$4$ = -52						; size = 4
_copy$3$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_len$5$ = -52						; size = 4
_len$1$ = -52						; size = 4
_copy$11$ = -48						; size = 4
_copy$8$ = -48						; size = 4
tv2786 = -48						; size = 4
tv2784 = -48						; size = 4
tv2756 = -48						; size = 4
_copy$1$ = -48						; size = 4
_len$4$ = -48						; size = 4
_len$3$ = -48						; size = 4
_len$2$ = -48						; size = 4
_last$ = -48						; size = 4
_here$ = -48						; size = 4
_ret$1$ = -44						; size = 4
_from$1$ = -40						; size = 4
tv2877 = -40						; size = 4
tv2813 = -40						; size = 4
tv2795 = -40						; size = 4
tv2781 = -40						; size = 4
tv2779 = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2785 = -20						; size = 4
tv2770 = -20						; size = 4
tv2769 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
tv2740 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 609  :     struct inflate_state FAR *state;
; 610  :     z_const unsigned char FAR *next;    /* next input */
; 611  :     unsigned char FAR *put;     /* next output */
; 612  :     unsigned have, left;        /* available input and output */
; 613  :     unsigned long hold;         /* bit buffer */
; 614  :     unsigned bits;              /* bits in bit buffer */
; 615  :     unsigned in, out;           /* save starting available input and output */
; 616  :     unsigned copy;              /* number of stored or match bytes to copy */
; 617  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 618  :     code here;                  /* current decoding table entry */
; 619  :     code last;                  /* parent table entry */
; 620  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 621  :     int ret;                    /* return code */
; 622  : #ifdef GUNZIP
; 623  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 624  : #endif
; 625  :     static const unsigned short order[19] = /* permutation of code lengths */
; 626  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 627  : 
; 628  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 629  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 b7 15 00
	00		 je	 $LN498@inflate
  00011	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00014	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 a9 15 00
	00		 je	 $LN498@inflate
  0001f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00023	0f 84 9f 15 00
	00		 je	 $LN498@inflate
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 0a		 jne	 SHORT $LN499@inflate
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	0f 85 90 15 00
	00		 jne	 $LN498@inflate
$LN499@inflate:

; 631  : 
; 632  :     state = (struct inflate_state FAR *)strm->state;
; 633  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00038	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  0003b	75 06		 jne	 SHORT $LN496@inflate
  0003d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN496@inflate:

; 634  :     LOAD();

  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	53		 push	 ebx
  00047	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004a	89 55 e0	 mov	 DWORD PTR _put$1$[ebp], edx
  0004d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00050	56		 push	 esi
  00051	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00054	89 55 e8	 mov	 DWORD PTR _left$1$[ebp], edx
  00057	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005a	57		 push	 edi
  0005b	8b 38		 mov	 edi, DWORD PTR [eax]

; 635  :     in = have;
; 636  :     out = left;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  00060	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 637  :     ret = Z_OK;

  00063	33 c0		 xor	 eax, eax
  00065	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0006d	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00070	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00073	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00076	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00079	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0007c	0f 87 2d 14 00
	00		 ja	 $LN12@inflate
$LL493@inflate:
  00082	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN837@inflate[eax*4]
$LN489@inflate:

; 640  :         case HEAD:
; 641  :             if (state->wrap == 0) {

  00089	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008c	89 45 cc	 mov	 DWORD PTR tv2861[ebp], eax
  0008f	85 c0		 test	 eax, eax
  00091	75 0b		 jne	 SHORT $LN487@inflate

; 642  :                 state->mode = TYPEDO;

  00093	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH

; 643  :                 break;

  00099	e9 06 14 00 00	 jmp	 $LN490@inflate
$LN487@inflate:

; 644  :             }
; 645  :             NEEDBITS(16);

  0009e	83 fe 10	 cmp	 esi, 16			; 00000010H
  000a1	73 2d		 jae	 SHORT $LN486@inflate
$LL484@inflate:
  000a3	85 db		 test	 ebx, ebx
  000a5	0f 84 aa 04 00
	00		 je	 $LN792@inflate
  000ab	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000ae	8b ce		 mov	 ecx, esi
  000b0	d3 e0		 shl	 eax, cl
  000b2	83 c6 08	 add	 esi, 8
  000b5	4b		 dec	 ebx
  000b6	47		 inc	 edi
  000b7	03 d0		 add	 edx, eax
  000b9	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000bc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000bf	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000c2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000c5	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c8	72 d9		 jb	 SHORT $LL484@inflate
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000cd	8b 45 cc	 mov	 eax, DWORD PTR tv2861[ebp]
$LN486@inflate:

; 646  : #ifdef GUNZIP
; 647  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000d0	a8 02		 test	 al, 2
  000d2	74 46		 je	 SHORT $LN478@inflate
  000d4	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000da	75 3e		 jne	 SHORT $LN478@inflate

; 648  :                 state->check = crc32(0L, Z_NULL, 0);

  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 _crc32@12
  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 649  :                 CRC2(state->check, hold);

  000ea	6a 02		 push	 2
  000ec	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  000ef	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  000f2	51		 push	 ecx
  000f3	50		 push	 eax
  000f4	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  000fa	e8 00 00 00 00	 call	 _crc32@12
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 650  :                 INITBITS();

  00102	33 d2		 xor	 edx, edx
  00104	33 f6		 xor	 esi, esi
  00106	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00109	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0010c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 651  :                 state->mode = FLAGS;

  0010f	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 652  :                 break;

  00115	e9 8a 13 00 00	 jmp	 $LN490@inflate
$LN478@inflate:

; 653  :             }
; 654  :             state->flags = 0;           /* expect zlib header */
; 655  :             if (state->head != Z_NULL)

  0011a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0011d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00124	85 c0		 test	 eax, eax
  00126	74 07		 je	 SHORT $LN471@inflate

; 656  :                 state->head->done = -1;

  00128	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN471@inflate:

; 657  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 658  : #else
; 659  :             if (
; 660  : #endif
; 661  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  0012f	f6 41 08 01	 test	 BYTE PTR [ecx+8], 1
  00133	0f 84 b5 00 00
	00		 je	 $LN469@inflate
  00139	0f b6 ca	 movzx	 ecx, dl
  0013c	8b c2		 mov	 eax, edx
  0013e	c1 e1 08	 shl	 ecx, 8
  00141	c1 e8 08	 shr	 eax, 8
  00144	03 c1		 add	 eax, ecx
  00146	33 d2		 xor	 edx, edx
  00148	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0014d	f7 f1		 div	 ecx

; 668  :                 state->mode = BAD;

  0014f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00152	85 d2		 test	 edx, edx
  00154	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00157	0f 85 91 00 00
	00		 jne	 $LN469@inflate

; 665  :             }
; 666  :             if (BITS(4) != Z_DEFLATED) {

  0015d	8b c2		 mov	 eax, edx
  0015f	24 0f		 and	 al, 15			; 0000000fH
  00161	3c 08		 cmp	 al, 8
  00163	74 0f		 je	 SHORT $LN467@inflate

; 667  :                 strm->msg = (char *)"unknown compression method";

  00165	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00168	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 669  :                 break;

  0016f	e9 2a 13 00 00	 jmp	 $LN831@inflate
$LN467@inflate:

; 670  :             }
; 671  :             DROPBITS(4);

  00174	c1 ea 04	 shr	 edx, 4

; 672  :             len = BITS(4) + 8;

  00177	8b c2		 mov	 eax, edx
  00179	83 e0 0f	 and	 eax, 15			; 0000000fH
  0017c	83 ee 04	 sub	 esi, 4
  0017f	83 c0 08	 add	 eax, 8

; 673  :             if (state->wbits == 0)

  00182	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00186	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00189	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0018c	89 45 cc	 mov	 DWORD PTR _len$1$[ebp], eax
  0018f	75 49		 jne	 SHORT $LN464@inflate

; 674  :                 state->wbits = len;

  00191	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN462@inflate:

; 679  :             }
; 680  :             state->dmax = 1U << len;

  00194	8b 4d cc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  00197	b8 01 00 00 00	 mov	 eax, 1
  0019c	d3 e0		 shl	 eax, cl
  0019e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 681  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 682  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001a1	6a 00		 push	 0
  001a3	6a 00		 push	 0
  001a5	6a 00		 push	 0
  001a7	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001aa	e8 00 00 00 00	 call	 _adler32@12
  001af	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001b2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001b5	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001b8	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 683  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001bb	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001be	c1 ea 08	 shr	 edx, 8
  001c1	f7 d2		 not	 edx
  001c3	83 e2 02	 and	 edx, 2
  001c6	83 ca 09	 or	 edx, 9
  001c9	89 11		 mov	 DWORD PTR [ecx], edx

; 684  :             INITBITS();

  001cb	33 d2		 xor	 edx, edx
  001cd	33 f6		 xor	 esi, esi
  001cf	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001d2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 685  :             break;

  001d5	e9 ca 12 00 00	 jmp	 $LN490@inflate
$LN464@inflate:

; 675  :             else if (len > state->wbits) {

  001da	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  001dd	76 b5		 jbe	 SHORT $LN462@inflate

; 676  :                 strm->msg = (char *)"invalid window size";

  001df	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001e2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 677  :                 state->mode = BAD;
; 678  :                 break;

  001e9	e9 b0 12 00 00	 jmp	 $LN831@inflate
$LN469@inflate:

; 662  :                 strm->msg = (char *)"incorrect header check";

  001ee	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001f1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 663  :                 state->mode = BAD;
; 664  :                 break;

  001f8	e9 a1 12 00 00	 jmp	 $LN831@inflate
$LN457@inflate:

; 686  : #ifdef GUNZIP
; 687  :         case FLAGS:
; 688  :             NEEDBITS(16);

  001fd	83 fe 10	 cmp	 esi, 16			; 00000010H
  00200	73 2a		 jae	 SHORT $LN456@inflate
$LL454@inflate:
  00202	85 db		 test	 ebx, ebx
  00204	0f 84 4b 03 00
	00		 je	 $LN792@inflate
  0020a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0020d	8b ce		 mov	 ecx, esi
  0020f	d3 e0		 shl	 eax, cl
  00211	83 c6 08	 add	 esi, 8
  00214	4b		 dec	 ebx
  00215	47		 inc	 edi
  00216	03 d0		 add	 edx, eax
  00218	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0021b	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0021e	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00221	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00224	83 fe 10	 cmp	 esi, 16			; 00000010H
  00227	72 d9		 jb	 SHORT $LL454@inflate
  00229	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN456@inflate:

; 689  :             state->flags = (int)(hold);

  0022c	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 690  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0022f	80 fa 08	 cmp	 dl, 8
  00232	74 0f		 je	 SHORT $LN448@inflate

; 691  :                 strm->msg = (char *)"unknown compression method";

  00234	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00237	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 692  :                 state->mode = BAD;
; 693  :                 break;

  0023e	e9 5b 12 00 00	 jmp	 $LN831@inflate
$LN448@inflate:

; 694  :             }
; 695  :             if (state->flags & 0xe000) {

  00243	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00249	74 0f		 je	 SHORT $LN447@inflate

; 696  :                 strm->msg = (char *)"unknown header flags set";

  0024b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0024e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 697  :                 state->mode = BAD;
; 698  :                 break;

  00255	e9 44 12 00 00	 jmp	 $LN831@inflate
$LN447@inflate:

; 699  :             }
; 700  :             if (state->head != Z_NULL)

  0025a	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0025d	85 f6		 test	 esi, esi
  0025f	74 0a		 je	 SHORT $LN446@inflate

; 701  :                 state->head->text = (int)((hold >> 8) & 1);

  00261	8b c2		 mov	 eax, edx
  00263	c1 e8 08	 shr	 eax, 8
  00266	83 e0 01	 and	 eax, 1
  00269	89 06		 mov	 DWORD PTR [esi], eax
$LN446@inflate:

; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0026b	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00272	74 1d		 je	 SHORT $LN442@inflate
  00274	6a 02		 push	 2
  00276	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00279	50		 push	 eax
  0027a	ff 71 18	 push	 DWORD PTR [ecx+24]
  0027d	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00280	c1 ea 08	 shr	 edx, 8
  00283	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00286	e8 00 00 00 00	 call	 _crc32@12
  0028b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0028e	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN442@inflate:

; 703  :             INITBITS();

  00291	33 d2		 xor	 edx, edx
  00293	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00296	33 f6		 xor	 esi, esi

; 704  :             state->mode = TIME;

  00298	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2

; 705  :         case TIME:
; 706  :             NEEDBITS(32);

  0029e	eb 05		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  002a0	83 fe 20	 cmp	 esi, 32			; 00000020H
  002a3	73 27		 jae	 SHORT $LN436@inflate
$LL434@inflate:
  002a5	85 db		 test	 ebx, ebx
  002a7	0f 84 a8 02 00
	00		 je	 $LN792@inflate
  002ad	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002b0	8b ce		 mov	 ecx, esi
  002b2	d3 e0		 shl	 eax, cl
  002b4	4b		 dec	 ebx
  002b5	47		 inc	 edi
  002b6	83 c6 08	 add	 esi, 8
  002b9	03 d0		 add	 edx, eax
  002bb	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002be	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002c1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  002c4	83 fe 20	 cmp	 esi, 32			; 00000020H
  002c7	72 dc		 jb	 SHORT $LL434@inflate
  002c9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN436@inflate:

; 707  :             if (state->head != Z_NULL)

  002cc	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002cf	85 c0		 test	 eax, eax
  002d1	74 03		 je	 SHORT $LN428@inflate

; 708  :                 state->head->time = hold;

  002d3	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN428@inflate:

; 709  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  002d6	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  002dd	74 2d		 je	 SHORT $LN424@inflate
  002df	8b c2		 mov	 eax, edx
  002e1	c1 e8 08	 shr	 eax, 8
  002e4	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002e7	8b c2		 mov	 eax, edx
  002e9	c1 e8 10	 shr	 eax, 16			; 00000010H
  002ec	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  002ef	6a 04		 push	 4
  002f1	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002f4	50		 push	 eax
  002f5	ff 71 18	 push	 DWORD PTR [ecx+24]
  002f8	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002fb	c1 ea 18	 shr	 edx, 24			; 00000018H
  002fe	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00301	e8 00 00 00 00	 call	 _crc32@12
  00306	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00309	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN424@inflate:

; 710  :             INITBITS();

  0030c	33 d2		 xor	 edx, edx
  0030e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00311	33 f6		 xor	 esi, esi

; 711  :             state->mode = OS;

  00313	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3

; 712  :         case OS:
; 713  :             NEEDBITS(16);

  00319	eb 05		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  0031b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0031e	73 27		 jae	 SHORT $LN418@inflate
$LL416@inflate:
  00320	85 db		 test	 ebx, ebx
  00322	0f 84 2d 02 00
	00		 je	 $LN792@inflate
  00328	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0032b	8b ce		 mov	 ecx, esi
  0032d	d3 e0		 shl	 eax, cl
  0032f	4b		 dec	 ebx
  00330	47		 inc	 edi
  00331	83 c6 08	 add	 esi, 8
  00334	03 d0		 add	 edx, eax
  00336	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00339	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0033c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0033f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00342	72 dc		 jb	 SHORT $LL416@inflate
  00344	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN418@inflate:

; 714  :             if (state->head != Z_NULL) {

  00347	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0034a	85 f6		 test	 esi, esi
  0034c	74 17		 je	 SHORT $LN410@inflate

; 715  :                 state->head->xflags = (int)(hold & 0xff);

  0034e	0f b6 c2	 movzx	 eax, dl
  00351	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 716  :                 state->head->os = (int)(hold >> 8);

  00354	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00357	8b ca		 mov	 ecx, edx
  00359	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0035c	c1 e9 08	 shr	 ecx, 8
  0035f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00362	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN410@inflate:

; 717  :             }
; 718  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00365	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0036c	74 1d		 je	 SHORT $LN406@inflate
  0036e	6a 02		 push	 2
  00370	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00373	50		 push	 eax
  00374	ff 71 18	 push	 DWORD PTR [ecx+24]
  00377	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0037a	c1 ea 08	 shr	 edx, 8
  0037d	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00380	e8 00 00 00 00	 call	 _crc32@12
  00385	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00388	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN406@inflate:

; 719  :             INITBITS();

  0038b	33 d2		 xor	 edx, edx
  0038d	33 f6		 xor	 esi, esi
  0038f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00392	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 720  :             state->mode = EXLEN;

  00395	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN402@inflate:

; 721  :         case EXLEN:
; 722  :             if (state->flags & 0x0400) {

  0039b	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  003a2	74 74		 je	 SHORT $LN401@inflate

; 723  :                 NEEDBITS(16);

  003a4	83 fe 10	 cmp	 esi, 16			; 00000010H
  003a7	73 2e		 jae	 SHORT $LN399@inflate
  003a9	8d a4 24 00 00
	00 00		 npad	 7
$LL397@inflate:
  003b0	85 db		 test	 ebx, ebx
  003b2	0f 84 9d 01 00
	00		 je	 $LN792@inflate
  003b8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003bb	8b ce		 mov	 ecx, esi
  003bd	d3 e0		 shl	 eax, cl
  003bf	4b		 dec	 ebx
  003c0	47		 inc	 edi
  003c1	83 c6 08	 add	 esi, 8
  003c4	03 d0		 add	 edx, eax
  003c6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  003c9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003cc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  003cf	83 fe 10	 cmp	 esi, 16			; 00000010H
  003d2	72 dc		 jb	 SHORT $LL397@inflate
  003d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN399@inflate:

; 724  :                 state->length = (unsigned)(hold);
; 725  :                 if (state->head != Z_NULL)

  003d7	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  003da	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  003dd	85 c0		 test	 eax, eax
  003df	74 03		 je	 SHORT $LN391@inflate

; 726  :                     state->head->extra_len = (unsigned)hold;

  003e1	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN391@inflate:

; 727  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  003e4	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  003eb	74 1d		 je	 SHORT $LN387@inflate
  003ed	6a 02		 push	 2
  003ef	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003f2	50		 push	 eax
  003f3	ff 71 18	 push	 DWORD PTR [ecx+24]
  003f6	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003f9	c1 ea 08	 shr	 edx, 8
  003fc	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003ff	e8 00 00 00 00	 call	 _crc32@12
  00404	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00407	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN387@inflate:

; 728  :                 INITBITS();

  0040a	33 f6		 xor	 esi, esi
  0040c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00413	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 729  :             }
; 730  :             else if (state->head != Z_NULL)

  00416	eb 0e		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  00418	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0041b	85 c0		 test	 eax, eax
  0041d	74 07		 je	 SHORT $LN382@inflate

; 731  :                 state->head->extra = Z_NULL;

  0041f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN382@inflate:

; 732  :             state->mode = EXTRA;

  00426	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN381@inflate:

; 733  :         case EXTRA:
; 734  :             if (state->flags & 0x0400) {

  0042c	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  00433	0f 84 8d 00 00
	00		 je	 $LN375@inflate

; 735  :                 copy = state->length;

  00439	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 736  :                 if (copy > have) copy = have;

  0043c	3b c3		 cmp	 eax, ebx
  0043e	8b d0		 mov	 edx, eax
  00440	0f 47 d3	 cmova	 edx, ebx
  00443	89 45 d0	 mov	 DWORD PTR _copy$1$[ebp], eax
  00446	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx

; 737  :                 if (copy) {

  00449	85 d2		 test	 edx, edx
  0044b	74 6f		 je	 SHORT $LN378@inflate

; 738  :                     if (state->head != Z_NULL &&
; 739  :                         state->head->extra != Z_NULL) {

  0044d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00450	85 c0		 test	 eax, eax
  00452	74 3f		 je	 SHORT $LN377@inflate
  00454	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00457	89 7d d8	 mov	 DWORD PTR tv2813[ebp], edi
  0045a	85 ff		 test	 edi, edi
  0045c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0045f	74 32		 je	 SHORT $LN377@inflate

; 740  :                         len = state->head->extra_len - state->length;

  00461	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00464	2b 4d d0	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  00467	89 4d d0	 mov	 DWORD PTR _len$2$[ebp], ecx

; 741  :                         zmemcpy(state->head->extra + len, next,
; 742  :                                 len + copy > state->head->extra_max ?
; 743  :                                 state->head->extra_max - len : copy);

  0046a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0046d	8b 45 d0	 mov	 eax, DWORD PTR _len$2$[ebp]
  00470	03 c2		 add	 eax, edx
  00472	3b c1		 cmp	 eax, ecx
  00474	8b 45 d0	 mov	 eax, DWORD PTR _len$2$[ebp]
  00477	76 04		 jbe	 SHORT $LN502@inflate
  00479	2b c8		 sub	 ecx, eax
  0047b	eb 02		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  0047d	8b ca		 mov	 ecx, edx
$LN503@inflate:
  0047f	03 45 d8	 add	 eax, DWORD PTR tv2813[ebp]
  00482	51		 push	 ecx
  00483	57		 push	 edi
  00484	50		 push	 eax
  00485	e8 00 00 00 00	 call	 _memcpy
  0048a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0048d	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  00490	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN377@inflate:

; 744  :                     }
; 745  :                     if (state->flags & 0x0200)

  00493	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0049a	74 10		 je	 SHORT $LN376@inflate

; 746  :                         state->check = crc32(state->check, next, copy);

  0049c	52		 push	 edx
  0049d	57		 push	 edi
  0049e	ff 71 18	 push	 DWORD PTR [ecx+24]
  004a1	e8 00 00 00 00	 call	 _crc32@12
  004a6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004a9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN376@inflate:

; 747  :                     have -= copy;

  004ac	8b 45 cc	 mov	 eax, DWORD PTR _copy$2$[ebp]
  004af	2b d8		 sub	 ebx, eax

; 748  :                     next += copy;

  004b1	03 f8		 add	 edi, eax

; 749  :                     state->length -= copy;

  004b3	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  004b6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  004b9	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN378@inflate:

; 750  :                 }
; 751  :                 if (state->length) goto inf_leave;

  004bc	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  004c0	0f 85 8f 00 00
	00		 jne	 $LN792@inflate
$LN375@inflate:

; 752  :             }
; 753  :             state->length = 0;

  004c6	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 754  :             state->mode = NAME;

  004cd	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
$LN374@inflate:

; 755  :         case NAME:
; 756  :             if (state->flags & 0x0800) {

  004d3	f7 41 10 00 08
	00 00		 test	 DWORD PTR [ecx+16], 2048 ; 00000800H
  004da	0f 84 f8 00 00
	00		 je	 $LN373@inflate

; 757  :                 if (have == 0) goto inf_leave;

  004e0	85 db		 test	 ebx, ebx
  004e2	74 71		 je	 SHORT $LN792@inflate

; 758  :                 copy = 0;

  004e4	33 d2		 xor	 edx, edx
$LL371@inflate:

; 759  :                 do {
; 760  :                     len = (unsigned)(next[copy++]);

  004e6	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  004ea	89 45 d0	 mov	 DWORD PTR _len$3$[ebp], eax

; 761  :                     if (state->head != Z_NULL &&
; 762  :                             state->head->name != Z_NULL &&
; 763  :                             state->length < state->head->name_max)

  004ed	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  004f0	42		 inc	 edx
  004f1	85 c0		 test	 eax, eax
  004f3	74 1e		 je	 SHORT $LN370@inflate
  004f5	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  004f8	85 f6		 test	 esi, esi
  004fa	74 17		 je	 SHORT $LN370@inflate
  004fc	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  004ff	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00502	73 0f		 jae	 SHORT $LN370@inflate

; 764  :                         state->head->name[state->length++] = len;

  00504	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00507	8b 5d d0	 mov	 ebx, DWORD PTR _len$3$[ebp]
  0050a	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0050d	ff 41 40	 inc	 DWORD PTR [ecx+64]
  00510	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN370@inflate:

; 765  :                 } while (len && copy < have);

  00513	8b 45 d0	 mov	 eax, DWORD PTR _len$3$[ebp]
  00516	85 c0		 test	 eax, eax
  00518	74 04		 je	 SHORT $LN367@inflate
  0051a	3b d3		 cmp	 edx, ebx
  0051c	72 c8		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 766  :                 if (state->flags & 0x0200)

  0051e	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00525	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00528	89 55 cc	 mov	 DWORD PTR _copy$3$[ebp], edx
  0052b	74 16		 je	 SHORT $LN366@inflate

; 767  :                     state->check = crc32(state->check, next, copy);

  0052d	52		 push	 edx
  0052e	57		 push	 edi
  0052f	ff 71 18	 push	 DWORD PTR [ecx+24]
  00532	e8 00 00 00 00	 call	 _crc32@12
  00537	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0053a	8b 55 cc	 mov	 edx, DWORD PTR _copy$3$[ebp]
  0053d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00540	8b 45 d0	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN366@inflate:

; 768  :                 have -= copy;

  00543	2b da		 sub	 ebx, edx

; 769  :                 next += copy;

  00545	03 fa		 add	 edi, edx
  00547	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0054a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 770  :                 if (len) goto inf_leave;

  0054d	85 c0		 test	 eax, eax
  0054f	0f 84 91 00 00
	00		 je	 $LN363@inflate
$LN792@inflate:
  00555	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN799@inflate:
  00558	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$839:

; 1222 :         }
; 1223 : 
; 1224 :     /*
; 1225 :        Return from inflate(), updating the total counts and the check value.
; 1226 :        If there was no progress during the inflate() call, return a buffer
; 1227 :        error.  Call updatewindow() to create and/or update the window state.
; 1228 :        Note: a memory error from inflate() is non-recoverable.
; 1229 :      */
; 1230 :   inf_leave:
; 1231 :     RESTORE();

  0055b	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0055e	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00561	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00564	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  00567	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0056a	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0056d	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00570	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00573	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  00576	89 0f		 mov	 DWORD PTR [edi], ecx

; 1232 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1233 :             (state->mode < CHECK || flush != Z_FINISH)))

  00578	83 7b 28 00	 cmp	 DWORD PTR [ebx+40], 0
  0057c	89 73 3c	 mov	 DWORD PTR [ebx+60], esi
  0057f	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  00582	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00585	75 22		 jne	 SHORT $LN6@inflate
  00587	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  0058a	0f 84 87 0f 00
	00		 je	 $LN5@inflate
  00590	8b 03		 mov	 eax, DWORD PTR [ebx]
  00592	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00595	0f 8d 7c 0f 00
	00		 jge	 $LN5@inflate
  0059b	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0059e	7c 09		 jl	 SHORT $LN6@inflate
  005a0	83 fa 04	 cmp	 edx, 4
  005a3	0f 84 6e 0f 00
	00		 je	 $LN5@inflate
$LN6@inflate:

; 1234 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  005a9	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  005ac	8b c6		 mov	 eax, esi
  005ae	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  005b1	8b cf		 mov	 ecx, edi
  005b3	50		 push	 eax
  005b4	e8 00 00 00 00	 call	 _updatewindow
  005b9	83 c4 04	 add	 esp, 4
  005bc	85 c0		 test	 eax, eax
  005be	0f 84 53 0f 00
	00		 je	 $LN5@inflate

; 1235 :             state->mode = MEM;

  005c4	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH
$LN13@inflate:
  005ca	5f		 pop	 edi
  005cb	5e		 pop	 esi

; 1236 :             return Z_MEM_ERROR;

  005cc	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  005d1	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  005d2	8b e5		 mov	 esp, ebp
  005d4	5d		 pop	 ebp
  005d5	c2 08 00	 ret	 8
$LN373@inflate:

; 771  :             }
; 772  :             else if (state->head != Z_NULL)

  005d8	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  005db	85 c0		 test	 eax, eax
  005dd	74 07		 je	 SHORT $LN363@inflate

; 773  :                 state->head->name = Z_NULL;

  005df	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN363@inflate:

; 774  :             state->length = 0;

  005e6	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 775  :             state->mode = COMMENT;

  005ed	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
$LN362@inflate:

; 776  :         case COMMENT:
; 777  :             if (state->flags & 0x1000) {

  005f3	f7 41 10 00 10
	00 00		 test	 DWORD PTR [ecx+16], 4096 ; 00001000H
  005fa	74 7b		 je	 SHORT $LN361@inflate

; 778  :                 if (have == 0) goto inf_leave;

  005fc	85 db		 test	 ebx, ebx
  005fe	0f 84 51 ff ff
	ff		 je	 $LN792@inflate

; 779  :                 copy = 0;

  00604	33 d2		 xor	 edx, edx
$LL359@inflate:

; 780  :                 do {
; 781  :                     len = (unsigned)(next[copy++]);

  00606	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  0060a	89 45 d0	 mov	 DWORD PTR _len$4$[ebp], eax

; 782  :                     if (state->head != Z_NULL &&
; 783  :                             state->head->comment != Z_NULL &&
; 784  :                             state->length < state->head->comm_max)

  0060d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00610	42		 inc	 edx
  00611	85 c0		 test	 eax, eax
  00613	74 1e		 je	 SHORT $LN358@inflate
  00615	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00618	85 f6		 test	 esi, esi
  0061a	74 17		 je	 SHORT $LN358@inflate
  0061c	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  0061f	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  00622	73 0f		 jae	 SHORT $LN358@inflate

; 785  :                         state->head->comment[state->length++] = len;

  00624	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00627	8b 5d d0	 mov	 ebx, DWORD PTR _len$4$[ebp]
  0062a	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0062d	ff 41 40	 inc	 DWORD PTR [ecx+64]
  00630	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN358@inflate:

; 786  :                 } while (len && copy < have);

  00633	8b 45 d0	 mov	 eax, DWORD PTR _len$4$[ebp]
  00636	85 c0		 test	 eax, eax
  00638	74 04		 je	 SHORT $LN355@inflate
  0063a	3b d3		 cmp	 edx, ebx
  0063c	72 c8		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 787  :                 if (state->flags & 0x0200)

  0063e	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00645	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00648	89 55 cc	 mov	 DWORD PTR _copy$4$[ebp], edx
  0064b	74 16		 je	 SHORT $LN354@inflate

; 788  :                     state->check = crc32(state->check, next, copy);

  0064d	52		 push	 edx
  0064e	57		 push	 edi
  0064f	ff 71 18	 push	 DWORD PTR [ecx+24]
  00652	e8 00 00 00 00	 call	 _crc32@12
  00657	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0065a	8b 55 cc	 mov	 edx, DWORD PTR _copy$4$[ebp]
  0065d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00660	8b 45 d0	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN354@inflate:

; 789  :                 have -= copy;

  00663	2b da		 sub	 ebx, edx

; 790  :                 next += copy;

  00665	03 fa		 add	 edi, edx
  00667	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0066a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 791  :                 if (len) goto inf_leave;

  0066d	85 c0		 test	 eax, eax
  0066f	0f 85 e0 fe ff
	ff		 jne	 $LN792@inflate

; 792  :             }
; 793  :             else if (state->head != Z_NULL)

  00675	eb 0e		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  00677	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0067a	85 c0		 test	 eax, eax
  0067c	74 07		 je	 SHORT $LN351@inflate

; 794  :                 state->head->comment = Z_NULL;

  0067e	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN351@inflate:
  00685	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 795  :             state->mode = HCRC;

  00688	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8
$LN350@inflate:

; 796  :         case HCRC:
; 797  :             if (state->flags & 0x0200) {

  0068e	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00695	74 56		 je	 SHORT $LN336@inflate

; 798  :                 NEEDBITS(16);

  00697	83 fe 10	 cmp	 esi, 16			; 00000010H
  0069a	73 2e		 jae	 SHORT $LN347@inflate
  0069c	8d 64 24 00	 npad	 4
$LL345@inflate:
  006a0	85 db		 test	 ebx, ebx
  006a2	0f 84 ad fe ff
	ff		 je	 $LN792@inflate
  006a8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  006ab	8b ce		 mov	 ecx, esi
  006ad	d3 e0		 shl	 eax, cl
  006af	83 c6 08	 add	 esi, 8
  006b2	4b		 dec	 ebx
  006b3	47		 inc	 edi
  006b4	03 d0		 add	 edx, eax
  006b6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006b9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  006bc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  006bf	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  006c2	83 fe 10	 cmp	 esi, 16			; 00000010H
  006c5	72 d9		 jb	 SHORT $LL345@inflate
  006c7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN347@inflate:

; 799  :                 if (hold != (state->check & 0xffff)) {

  006ca	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  006ce	3b d0		 cmp	 edx, eax
  006d0	74 0f		 je	 SHORT $LN338@inflate

; 800  :                     strm->msg = (char *)"header crc mismatch";

  006d2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006d5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 801  :                     state->mode = BAD;
; 802  :                     break;

  006dc	e9 bd 0d 00 00	 jmp	 $LN831@inflate
$LN338@inflate:

; 803  :                 }
; 804  :                 INITBITS();

  006e1	33 f6		 xor	 esi, esi
  006e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  006ea	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN336@inflate:

; 805  :             }
; 806  :             if (state->head != Z_NULL) {

  006ed	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  006f0	85 d2		 test	 edx, edx
  006f2	74 16		 je	 SHORT $LN335@inflate

; 807  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006f4	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  006f7	c1 f8 09	 sar	 eax, 9
  006fa	83 e0 01	 and	 eax, 1
  006fd	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 808  :                 state->head->done = 1;

  00700	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00703	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN335@inflate:

; 809  :             }
; 810  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0070a	6a 00		 push	 0
  0070c	6a 00		 push	 0
  0070e	6a 00		 push	 0
  00710	e8 00 00 00 00	 call	 _crc32@12
  00715	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00718	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0071b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0071e	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 811  :             state->mode = TYPE;
; 812  :             break;

  00721	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00724	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
  0072a	e9 75 0d 00 00	 jmp	 $LN490@inflate
$LN333@inflate:

; 813  : #endif
; 814  :         case DICTID:
; 815  :             NEEDBITS(32);

  0072f	83 fe 20	 cmp	 esi, 32			; 00000020H
  00732	73 24		 jae	 SHORT $LN332@inflate
$LL330@inflate:
  00734	85 db		 test	 ebx, ebx
  00736	0f 84 19 fe ff
	ff		 je	 $LN792@inflate
  0073c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0073f	8b ce		 mov	 ecx, esi
  00741	d3 e0		 shl	 eax, cl
  00743	4b		 dec	 ebx
  00744	47		 inc	 edi
  00745	83 c6 08	 add	 esi, 8
  00748	03 d0		 add	 edx, eax
  0074a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0074d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00750	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00753	83 fe 20	 cmp	 esi, 32			; 00000020H
  00756	72 dc		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 816  :             strm->adler = state->check = ZSWAP32(hold);

  00758	8b ca		 mov	 ecx, edx
  0075a	8b c2		 mov	 eax, edx
  0075c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0075f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00765	03 c8		 add	 ecx, eax
  00767	8b c2		 mov	 eax, edx
  00769	c1 e8 08	 shr	 eax, 8
  0076c	c1 e1 08	 shl	 ecx, 8
  0076f	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00774	c1 ea 18	 shr	 edx, 24			; 00000018H
  00777	03 c1		 add	 eax, ecx
  00779	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0077c	03 c2		 add	 eax, edx
  0077e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00781	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00784	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 817  :             INITBITS();

  00787	33 d2		 xor	 edx, edx
  00789	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0078c	33 f6		 xor	 esi, esi

; 818  :             state->mode = DICT;

  0078e	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH
$LN321@inflate:

; 819  :         case DICT:
; 820  :             if (state->havedict == 0) {

  00794	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00798	0f 84 1f 0d 00
	00		 je	 $LN579@inflate

; 823  :             }
; 824  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0079e	6a 00		 push	 0
  007a0	6a 00		 push	 0
  007a2	6a 00		 push	 0
  007a4	e8 00 00 00 00	 call	 _adler32@12
  007a9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007ac	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007af	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  007b2	89 42 30	 mov	 DWORD PTR [edx+48], eax
  007b5	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 825  :             state->mode = TYPE;

  007b8	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
$LN316@inflate:

; 826  :         case TYPE:
; 827  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  007be	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  007c1	83 f8 05	 cmp	 eax, 5
  007c4	0f 84 8b fd ff
	ff		 je	 $LN792@inflate
  007ca	83 f8 06	 cmp	 eax, 6
  007cd	0f 84 82 fd ff
	ff		 je	 $LN792@inflate
$LN315@inflate:

; 828  :         case TYPEDO:
; 829  :             if (state->last) {

  007d3	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  007d7	74 1d		 je	 SHORT $LN308@inflate

; 830  :                 BYTEBITS();

  007d9	8b ce		 mov	 ecx, esi
  007db	83 e1 07	 and	 ecx, 7
  007de	d3 ea		 shr	 edx, cl
  007e0	2b f1		 sub	 esi, ecx

; 831  :                 state->mode = CHECK;

  007e2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007e5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  007e8	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007eb	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH

; 832  :                 break;

  007f1	e9 ae 0c 00 00	 jmp	 $LN490@inflate
$LN308@inflate:

; 833  :             }
; 834  :             NEEDBITS(3);

  007f6	83 fe 03	 cmp	 esi, 3
  007f9	73 2c		 jae	 SHORT $LN307@inflate
  007fb	eb 03 8d 49 00	 npad	 5
$LL305@inflate:
  00800	85 db		 test	 ebx, ebx
  00802	0f 84 4d fd ff
	ff		 je	 $LN792@inflate
  00808	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0080b	8b ce		 mov	 ecx, esi
  0080d	d3 e0		 shl	 eax, cl
  0080f	4b		 dec	 ebx
  00810	47		 inc	 edi
  00811	83 c6 08	 add	 esi, 8
  00814	03 d0		 add	 edx, eax
  00816	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00819	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0081c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0081f	83 fe 03	 cmp	 esi, 3
  00822	72 dc		 jb	 SHORT $LL305@inflate
  00824	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 835  :             state->last = BITS(1);

  00827	8b c2		 mov	 eax, edx
  00829	83 e0 01	 and	 eax, 1

; 836  :             DROPBITS(1);

  0082c	d1 ea		 shr	 edx, 1
  0082e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 837  :             switch (BITS(2)) {

  00831	8b c2		 mov	 eax, edx
  00833	83 e0 03	 and	 eax, 3
  00836	83 f8 03	 cmp	 eax, 3
  00839	77 64		 ja	 SHORT $LN286@inflate
  0083b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN838@inflate[eax*4]
$LN294@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  00842	c1 ea 02	 shr	 edx, 2
  00845	83 ee 03	 sub	 esi, 3
  00848	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  0084e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00851	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  00854	e9 4b 0c 00 00	 jmp	 $LN490@inflate
$LN293@inflate:

; 838  :             case 0:                             /* stored block */
; 839  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 840  :                         state->last ? " (last)" : ""));
; 841  :                 state->mode = STORED;
; 842  :                 break;
; 843  :             case 1:                             /* fixed block */
; 844  :                 fixedtables(state);

  00859	e8 00 00 00 00	 call	 _fixedtables

; 845  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 846  :                         state->last ? " (last)" : ""));
; 847  :                 state->mode = LEN_;             /* decode codes */
; 848  :                 if (flush == Z_TREES) {

  0085e	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00862	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00868	75 35		 jne	 SHORT $LN286@inflate

; 849  :                     DROPBITS(2);

  0086a	c1 ea 02	 shr	 edx, 2
  0086d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00870	83 ee 03	 sub	 esi, 3

; 850  :                     goto inf_leave;

  00873	e9 dd fc ff ff	 jmp	 $LN792@inflate
$LN288@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  00878	c1 ea 02	 shr	 edx, 2
  0087b	83 ee 03	 sub	 esi, 3
  0087e	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H
  00884	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00887	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  0088a	e9 15 0c 00 00	 jmp	 $LN490@inflate
$LN287@inflate:

; 851  :                 }
; 852  :                 break;
; 853  :             case 2:                             /* dynamic block */
; 854  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 855  :                         state->last ? " (last)" : ""));
; 856  :                 state->mode = TABLE;
; 857  :                 break;
; 858  :             case 3:
; 859  :                 strm->msg = (char *)"invalid block type";

  0088f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00892	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 860  :                 state->mode = BAD;

  00899	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN286@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  0089f	c1 ea 02	 shr	 edx, 2
  008a2	83 ee 03	 sub	 esi, 3
  008a5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  008ab	e9 f4 0b 00 00	 jmp	 $LN490@inflate
$LN282@inflate:

; 864  :         case STORED:
; 865  :             BYTEBITS();                         /* go to byte boundary */

  008b0	8b ce		 mov	 ecx, esi
  008b2	83 e1 07	 and	 ecx, 7
  008b5	d3 ea		 shr	 edx, cl
  008b7	2b f1		 sub	 esi, ecx
  008b9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  008bc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 866  :             NEEDBITS(32);

  008bf	83 fe 20	 cmp	 esi, 32			; 00000020H
  008c2	73 27		 jae	 SHORT $LN278@inflate
$LL276@inflate:
  008c4	85 db		 test	 ebx, ebx
  008c6	0f 84 89 fc ff
	ff		 je	 $LN792@inflate
  008cc	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  008cf	8b ce		 mov	 ecx, esi
  008d1	d3 e0		 shl	 eax, cl
  008d3	83 c6 08	 add	 esi, 8
  008d6	4b		 dec	 ebx
  008d7	47		 inc	 edi
  008d8	03 d0		 add	 edx, eax
  008da	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  008dd	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008e0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  008e3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  008e6	83 fe 20	 cmp	 esi, 32			; 00000020H
  008e9	72 d9		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 867  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  008eb	8b c2		 mov	 eax, edx
  008ed	8b ca		 mov	 ecx, edx
  008ef	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  008f5	f7 d0		 not	 eax
  008f7	c1 e8 10	 shr	 eax, 16			; 00000010H
  008fa	89 4d cc	 mov	 DWORD PTR tv2804[ebp], ecx
  008fd	3b c8		 cmp	 ecx, eax

; 869  :                 state->mode = BAD;

  008ff	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00902	74 0f		 je	 SHORT $LN270@inflate

; 868  :                 strm->msg = (char *)"invalid stored block lengths";

  00904	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00907	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 870  :                 break;

  0090e	e9 8b 0b 00 00	 jmp	 $LN831@inflate
$LN270@inflate:

; 871  :             }
; 872  :             state->length = (unsigned)hold & 0xffff;

  00913	8b 45 cc	 mov	 eax, DWORD PTR tv2804[ebp]

; 873  :             Tracev((stderr, "inflate:       stored length %u\n",
; 874  :                     state->length));
; 875  :             INITBITS();

  00916	33 d2		 xor	 edx, edx
  00918	33 f6		 xor	 esi, esi

; 876  :             state->mode = COPY_;
; 877  :             if (flush == Z_TREES) goto inf_leave;

  0091a	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0091e	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  00921	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00924	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00927	c7 01 0e 00 00
	00		 mov	 DWORD PTR [ecx], 14	; 0000000eH
  0092d	0f 84 22 fc ff
	ff		 je	 $LN792@inflate
$LN266@inflate:

; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  00933	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN264@inflate:

; 880  :         case COPY:
; 881  :             copy = state->length;

  00939	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 882  :             if (copy) {

  0093c	85 c0		 test	 eax, eax
  0093e	0f 84 cc 06 00
	00		 je	 $LN263@inflate

; 883  :                 if (copy > have) copy = have;

  00944	3b c3		 cmp	 eax, ebx
  00946	0f 47 c3	 cmova	 eax, ebx

; 884  :                 if (copy > left) copy = left;

  00949	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  0094c	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  00950	89 45 cc	 mov	 DWORD PTR _copy$7$[ebp], eax

; 885  :                 if (copy == 0) goto inf_leave;

  00953	85 c0		 test	 eax, eax
  00955	0f 84 fa fb ff
	ff		 je	 $LN792@inflate

; 886  :                 zmemcpy(put, next, copy);

  0095b	50		 push	 eax
  0095c	57		 push	 edi
  0095d	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  00960	e8 00 00 00 00	 call	 _memcpy

; 887  :                 have -= copy;

  00965	8b 45 cc	 mov	 eax, DWORD PTR _copy$7$[ebp]

; 888  :                 next += copy;
; 889  :                 left -= copy;
; 890  :                 put += copy;
; 891  :                 state->length -= copy;

  00968	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0096b	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  0096e	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax

; 892  :                 break;

  00971	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00974	2b d8		 sub	 ebx, eax
  00976	03 f8		 add	 edi, eax
  00978	83 c4 0c	 add	 esp, 12			; 0000000cH
  0097b	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  0097e	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00981	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00984	e9 1b 0b 00 00	 jmp	 $LN490@inflate
$LN258@inflate:

; 893  :             }
; 894  :             Tracev((stderr, "inflate:       stored end\n"));
; 895  :             state->mode = TYPE;
; 896  :             break;
; 897  :         case TABLE:
; 898  :             NEEDBITS(14);

  00989	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0098c	73 29		 jae	 SHORT $LN257@inflate
  0098e	8b ff		 npad	 2
$LL255@inflate:
  00990	85 db		 test	 ebx, ebx
  00992	0f 84 bd fb ff
	ff		 je	 $LN792@inflate
  00998	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0099b	8b ce		 mov	 ecx, esi
  0099d	d3 e0		 shl	 eax, cl
  0099f	4b		 dec	 ebx
  009a0	47		 inc	 edi
  009a1	83 c6 08	 add	 esi, 8
  009a4	03 d0		 add	 edx, eax
  009a6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009a9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009ac	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  009af	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009b2	72 dc		 jb	 SHORT $LL255@inflate
  009b4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN257@inflate:

; 899  :             state->nlen = BITS(5) + 257;

  009b7	8b c2		 mov	 eax, edx
  009b9	83 e0 1f	 and	 eax, 31			; 0000001fH
  009bc	05 01 01 00 00	 add	 eax, 257		; 00000101H
  009c1	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 900  :             DROPBITS(5);

  009c4	c1 ea 05	 shr	 edx, 5

; 901  :             state->ndist = BITS(5) + 1;

  009c7	8b c2		 mov	 eax, edx
  009c9	83 e0 1f	 and	 eax, 31			; 0000001fH
  009cc	40		 inc	 eax

; 902  :             DROPBITS(5);

  009cd	c1 ea 05	 shr	 edx, 5
  009d0	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 903  :             state->ncode = BITS(4) + 4;

  009d3	8b c2		 mov	 eax, edx
  009d5	83 e0 0f	 and	 eax, 15			; 0000000fH
  009d8	83 c0 04	 add	 eax, 4

; 904  :             DROPBITS(4);

  009db	c1 ea 04	 shr	 edx, 4
  009de	83 ee 0e	 sub	 esi, 14			; 0000000eH

; 905  : #ifndef PKZIP_BUG_WORKAROUND
; 906  :             if (state->nlen > 286 || state->ndist > 30) {

  009e1	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  009e8	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  009eb	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009ee	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009f1	0f 87 f5 00 00
	00		 ja	 $LN239@inflate
  009f7	83 79 64 1e	 cmp	 DWORD PTR [ecx+100], 30	; 0000001eH
  009fb	0f 87 eb 00 00
	00		 ja	 $LN239@inflate

; 910  :             }
; 911  : #endif
; 912  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 913  :             state->have = 0;

  00a01	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 914  :             state->mode = LENLENS;

  00a08	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN525@inflate:

; 915  :         case LENLENS:
; 916  :             while (state->have < state->ncode) {

  00a0e	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a11	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a14	73 65		 jae	 SHORT $LN527@inflate
$LL237@inflate:

; 917  :                 NEEDBITS(3);

  00a16	83 fe 03	 cmp	 esi, 3
  00a19	73 29		 jae	 SHORT $LN234@inflate
  00a1b	eb 03 8d 49 00	 npad	 5
$LL232@inflate:
  00a20	85 db		 test	 ebx, ebx
  00a22	0f 84 2d fb ff
	ff		 je	 $LN792@inflate
  00a28	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a2b	8b ce		 mov	 ecx, esi
  00a2d	d3 e0		 shl	 eax, cl
  00a2f	4b		 dec	 ebx
  00a30	47		 inc	 edi
  00a31	83 c6 08	 add	 esi, 8
  00a34	03 d0		 add	 edx, eax
  00a36	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a39	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a3c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a3f	83 fe 03	 cmp	 esi, 3
  00a42	72 dc		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 918  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a44	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a47	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a4a	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00a4d	8b ca		 mov	 ecx, edx
  00a4f	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a57	83 e1 07	 and	 ecx, 7
  00a5a	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  00a5f	8b cf		 mov	 ecx, edi
  00a61	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a64	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a67	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]

; 919  :                 DROPBITS(3);

  00a6a	c1 ea 03	 shr	 edx, 3
  00a6d	83 ee 03	 sub	 esi, 3
  00a70	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a73	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a76	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a79	72 9b		 jb	 SHORT $LL237@inflate
$LN527@inflate:

; 920  :             }
; 921  :             while (state->have < 19)

  00a7b	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a7f	73 1b		 jae	 SHORT $LN222@inflate
$LL223@inflate:

; 922  :                 state->lens[order[state->have++]] = 0;

  00a81	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a84	33 d2		 xor	 edx, edx
  00a86	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a8e	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00a93	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a96	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a9a	72 e5		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 923  :             state->next = state->codes;

  00a9c	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]
  00a9f	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00aa5	89 02		 mov	 DWORD PTR [edx], eax

; 924  :             state->lencode = (const code FAR *)(state->next);

  00aa7	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 925  :             state->lenbits = 7;
; 926  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 927  :                                 &(state->lenbits), state->work);

  00aaa	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00aad	83 c1 54	 add	 ecx, 84			; 00000054H
  00ab0	05 f0 02 00 00	 add	 eax, 752		; 000002f0H
  00ab5	50		 push	 eax
  00ab6	51		 push	 ecx
  00ab7	52		 push	 edx
  00ab8	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00abb	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
  00ac1	6a 13		 push	 19			; 00000013H
  00ac3	8d 52 70	 lea	 edx, DWORD PTR [edx+112]
  00ac6	33 c9		 xor	 ecx, ecx
  00ac8	e8 00 00 00 00	 call	 _inflate_table

; 930  :                 state->mode = BAD;

  00acd	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 931  :                 break;

  00ad0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00ad3	83 c4 10	 add	 esp, 16			; 00000010H
  00ad6	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ad9	85 c0		 test	 eax, eax
  00adb	74 1e		 je	 SHORT $LN221@inflate

; 928  :             if (ret) {
; 929  :                 strm->msg = (char *)"invalid code lengths set";

  00add	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ae0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 931  :                 break;

  00ae7	e9 b2 09 00 00	 jmp	 $LN831@inflate
$LN239@inflate:

; 907  :                 strm->msg = (char *)"too many length or distance symbols";

  00aec	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00aef	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 908  :                 state->mode = BAD;
; 909  :                 break;

  00af6	e9 a3 09 00 00	 jmp	 $LN831@inflate
$LN221@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 934  :             state->have = 0;

  00afb	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 935  :             state->mode = CODELENS;

  00b02	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$LN528@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00b08	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00b0b	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b0e	89 45 d8	 mov	 DWORD PTR tv2795[ebp], eax
  00b11	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00b14	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00b17	39 45 d8	 cmp	 DWORD PTR tv2795[ebp], eax
  00b1a	0f 83 0e 02 00
	00		 jae	 $LN218@inflate
$LL219@inflate:

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  00b20	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00b23	b8 01 00 00 00	 mov	 eax, 1
  00b28	d3 e0		 shl	 eax, cl
  00b2a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00b2d	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b30	89 4d ec	 mov	 DWORD PTR tv2785[ebp], ecx
  00b33	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00b36	89 45 cc	 mov	 DWORD PTR tv2783[ebp], eax
  00b39	8b c1		 mov	 eax, ecx
  00b3b	8b 4d cc	 mov	 ecx, DWORD PTR tv2783[ebp]
  00b3e	23 c2		 and	 eax, edx
  00b40	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 940  :                     if ((unsigned)(here.bits) <= bits) break;

  00b43	8b c8		 mov	 ecx, eax
  00b45	c1 e9 08	 shr	 ecx, 8
  00b48	0f b6 c9	 movzx	 ecx, cl
  00b4b	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00b4e	3b ce		 cmp	 ecx, esi
  00b50	76 39		 jbe	 SHORT $LN555@inflate
$LL217@inflate:

; 941  :                     PULLBYTE();

  00b52	85 db		 test	 ebx, ebx
  00b54	0f 84 fb f9 ff
	ff		 je	 $LN792@inflate
  00b5a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00b5d	8b ce		 mov	 ecx, esi
  00b5f	d3 e0		 shl	 eax, cl
  00b61	8b 4d cc	 mov	 ecx, DWORD PTR tv2783[ebp]
  00b64	4b		 dec	 ebx
  00b65	47		 inc	 edi
  00b66	03 d0		 add	 edx, eax
  00b68	8b 45 ec	 mov	 eax, DWORD PTR tv2785[ebp]
  00b6b	23 c2		 and	 eax, edx
  00b6d	83 c6 08	 add	 esi, 8
  00b70	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00b73	8b c8		 mov	 ecx, eax
  00b75	c1 e9 08	 shr	 ecx, 8
  00b78	0f b6 c9	 movzx	 ecx, cl
  00b7b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00b7e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00b81	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00b84	89 45 d0	 mov	 DWORD PTR _here$[ebp], eax
  00b87	3b ce		 cmp	 ecx, esi
  00b89	77 c7		 ja	 SHORT $LL217@inflate
$LN555@inflate:

; 942  :                 }
; 943  :                 if (here.val < 16) {

  00b8b	8b c8		 mov	 ecx, eax
  00b8d	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00b90	89 4d cc	 mov	 DWORD PTR tv2772[ebp], ecx
  00b93	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00b97	73 26		 jae	 SHORT $LN832@inflate

; 944  :                     DROPBITS(here.bits);
; 945  :                     state->lens[state->have++] = here.val;

  00b99	8b 7d d8	 mov	 edi, DWORD PTR tv2795[ebp]
  00b9c	c1 e8 08	 shr	 eax, 8
  00b9f	0f b6 c8	 movzx	 ecx, al
  00ba2	8b 45 cc	 mov	 eax, DWORD PTR tv2772[ebp]
  00ba5	d3 ea		 shr	 edx, cl
  00ba7	2b f1		 sub	 esi, ecx
  00ba9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00bac	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00baf	66 89 44 79 70	 mov	 WORD PTR [ecx+edi*2+112], ax
  00bb4	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00bb7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 946  :                 }
; 947  :                 else {

  00bba	e9 57 01 00 00	 jmp	 $LN835@inflate
$LN832@inflate:

; 948  :                     if (here.val == 16) {

  00bbf	75 6d		 jne	 SHORT $LN205@inflate

; 949  :                         NEEDBITS(here.bits + 2);

  00bc1	8b c8		 mov	 ecx, eax
  00bc3	c1 e9 08	 shr	 ecx, 8
  00bc6	0f b6 c9	 movzx	 ecx, cl
  00bc9	83 c1 02	 add	 ecx, 2
  00bcc	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  00bcf	3b f1		 cmp	 esi, ecx
  00bd1	73 25		 jae	 SHORT $LN203@inflate
$LL201@inflate:
  00bd3	85 db		 test	 ebx, ebx
  00bd5	0f 84 7a f9 ff
	ff		 je	 $LN792@inflate
  00bdb	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00bde	8b ce		 mov	 ecx, esi
  00be0	d3 e2		 shl	 edx, cl
  00be2	4b		 dec	 ebx
  00be3	47		 inc	 edi
  00be4	83 c6 08	 add	 esi, 8
  00be7	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00bea	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bed	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00bf0	3b 75 cc	 cmp	 esi, DWORD PTR $T1[ebp]
  00bf3	72 de		 jb	 SHORT $LL201@inflate
  00bf5	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN203@inflate:

; 950  :                         DROPBITS(here.bits);

  00bf8	0f b6 cc	 movzx	 ecx, ah

; 951  :                         if (state->have == 0) {

  00bfb	8b 45 d8	 mov	 eax, DWORD PTR tv2795[ebp]
  00bfe	d3 ea		 shr	 edx, cl
  00c00	2b f1		 sub	 esi, ecx

; 955  :                         }
; 956  :                         len = state->lens[state->have - 1];

  00c02	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c05	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c08	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c0b	85 c0		 test	 eax, eax
  00c0d	0f 84 3d 01 00
	00		 je	 $LN560@inflate
  00c13	0f b7 44 41 6e	 movzx	 eax, WORD PTR [ecx+eax*2+110]

; 957  :                         copy = 3 + BITS(2);

  00c18	8b ca		 mov	 ecx, edx
  00c1a	83 e1 03	 and	 ecx, 3
  00c1d	83 c1 03	 add	 ecx, 3

; 958  :                         DROPBITS(2);

  00c20	c1 ea 02	 shr	 edx, 2
  00c23	89 45 cc	 mov	 DWORD PTR _len$5$[ebp], eax
  00c26	83 ee 02	 sub	 esi, 2

; 959  :                     }
; 960  :                     else if (here.val == 17) {

  00c29	e9 a9 00 00 00	 jmp	 $LN833@inflate
$LN205@inflate:
  00c2e	66 83 7d d2 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H
  00c33	0f b6 cc	 movzx	 ecx, ah
  00c36	75 4a		 jne	 SHORT $LN170@inflate

; 961  :                         NEEDBITS(here.bits + 3);

  00c38	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c3b	89 4d ec	 mov	 DWORD PTR tv2770[ebp], ecx
  00c3e	3b f0		 cmp	 esi, eax
  00c40	73 29		 jae	 SHORT $LN185@inflate
$LL183@inflate:
  00c42	85 db		 test	 ebx, ebx
  00c44	0f 84 0b f9 ff
	ff		 je	 $LN792@inflate
  00c4a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c4d	8b ce		 mov	 ecx, esi
  00c4f	d3 e0		 shl	 eax, cl
  00c51	8b 4d ec	 mov	 ecx, DWORD PTR tv2770[ebp]
  00c54	4b		 dec	 ebx
  00c55	47		 inc	 edi
  00c56	03 d0		 add	 edx, eax
  00c58	83 c6 08	 add	 esi, 8
  00c5b	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c5e	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c61	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c64	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c67	3b f0		 cmp	 esi, eax
  00c69	72 d7		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 962  :                         DROPBITS(here.bits);

  00c6b	d3 ea		 shr	 edx, cl

; 963  :                         len = 0;
; 964  :                         copy = 3 + BITS(3);
; 965  :                         DROPBITS(3);

  00c6d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00c72	8b ca		 mov	 ecx, edx
  00c74	83 e1 07	 and	 ecx, 7
  00c77	83 c1 03	 add	 ecx, 3
  00c7a	c1 ea 03	 shr	 edx, 3
  00c7d	2b 45 ec	 sub	 eax, DWORD PTR tv2770[ebp]

; 966  :                     }
; 967  :                     else {

  00c80	eb 4c		 jmp	 SHORT $LN834@inflate
$LN170@inflate:

; 968  :                         NEEDBITS(here.bits + 7);

  00c82	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00c85	89 4d ec	 mov	 DWORD PTR tv2769[ebp], ecx
  00c88	3b f0		 cmp	 esi, eax
  00c8a	73 2d		 jae	 SHORT $LN169@inflate
  00c8c	8d 64 24 00	 npad	 4
$LL167@inflate:
  00c90	85 db		 test	 ebx, ebx
  00c92	0f 84 bd f8 ff
	ff		 je	 $LN792@inflate
  00c98	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c9b	8b ce		 mov	 ecx, esi
  00c9d	d3 e0		 shl	 eax, cl
  00c9f	8b 4d ec	 mov	 ecx, DWORD PTR tv2769[ebp]
  00ca2	4b		 dec	 ebx
  00ca3	47		 inc	 edi
  00ca4	03 d0		 add	 edx, eax
  00ca6	83 c6 08	 add	 esi, 8
  00ca9	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00cac	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00caf	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cb2	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00cb5	3b f0		 cmp	 esi, eax
  00cb7	72 d7		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 969  :                         DROPBITS(here.bits);

  00cb9	d3 ea		 shr	 edx, cl

; 970  :                         len = 0;
; 971  :                         copy = 11 + BITS(7);
; 972  :                         DROPBITS(7);

  00cbb	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00cc0	8b ca		 mov	 ecx, edx
  00cc2	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00cc5	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00cc8	c1 ea 07	 shr	 edx, 7
  00ccb	2b 45 ec	 sub	 eax, DWORD PTR tv2769[ebp]
$LN834@inflate:
  00cce	03 f0		 add	 esi, eax
  00cd0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
$LN833@inflate:

; 973  :                     }
; 974  :                     if (state->have + copy > state->nlen + state->ndist) {

  00cd7	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00cda	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00cdd	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00ce0	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00ce3	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00ce6	89 4d d0	 mov	 DWORD PTR _copy$8$[ebp], ecx
  00ce9	03 4d d8	 add	 ecx, DWORD PTR tv2795[ebp]
  00cec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cef	3b c8		 cmp	 ecx, eax
  00cf1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cf4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cf7	77 57		 ja	 SHORT $LN560@inflate

; 975  :                         strm->msg = (char *)"invalid bit length repeat";
; 976  :                         state->mode = BAD;
; 977  :                         break;
; 978  :                     }
; 979  :                     while (copy--)

  00cf9	83 7d d0 00	 cmp	 DWORD PTR _copy$8$[ebp], 0
  00cfd	74 1a		 je	 SHORT $LN603@inflate
  00cff	8b 5d d0	 mov	 ebx, DWORD PTR _copy$8$[ebp]
  00d02	8b 7d cc	 mov	 edi, DWORD PTR _len$5$[ebp]
$LL154@inflate:

; 980  :                         state->lens[state->have++] = (unsigned short)len;

  00d05	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00d08	66 89 7c 41 70	 mov	 WORD PTR [ecx+eax*2+112], di
  00d0d	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00d10	4b		 dec	 ebx
  00d11	75 f2		 jne	 SHORT $LL154@inflate
  00d13	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN835@inflate:
  00d16	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LN603@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00d19	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00d1c	89 45 d8	 mov	 DWORD PTR tv2795[ebp], eax
  00d1f	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00d22	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00d25	39 45 d8	 cmp	 DWORD PTR tv2795[ebp], eax
  00d28	0f 82 f2 fd ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 981  :                 }
; 982  :             }
; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  00d2e	83 39 1d	 cmp	 DWORD PTR [ecx], 29	; 0000001dH
  00d31	0f 84 6d 07 00
	00		 je	 $LN490@inflate

; 986  : 
; 987  :             /* check for end-of-block code (better have one) */
; 988  :             if (state->lens[256] == 0) {

  00d37	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00d3f	75 1e		 jne	 SHORT $LN151@inflate

; 989  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d41	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d44	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 990  :                 state->mode = BAD;
; 991  :                 break;

  00d4b	e9 4e 07 00 00	 jmp	 $LN831@inflate
$LN560@inflate:

; 952  :                             strm->msg = (char *)"invalid bit length repeat";

  00d50	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d53	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 953  :                             state->mode = BAD;
; 954  :                             break;

  00d5a	e9 3f 07 00 00	 jmp	 $LN831@inflate
$LN151@inflate:

; 992  :             }
; 993  : 
; 994  :             /* build code tables -- note: do not change the lenbits or distbits
; 995  :                values here (9 and 6) without reading the comments in inftrees.h
; 996  :                concerning the ENOUGH constants, which depend on those values */
; 997  :             state->next = state->codes;

  00d5f	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]
  00d62	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]

; 998  :             state->lencode = (const code FAR *)(state->next);
; 999  :             state->lenbits = 9;
; 1000 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1001 :                                 &(state->lenbits), state->work);

  00d68	8d b9 f0 02 00
	00		 lea	 edi, DWORD PTR [ecx+752]
  00d6e	89 02		 mov	 DWORD PTR [edx], eax
  00d70	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00d73	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00d76	57		 push	 edi
  00d77	50		 push	 eax
  00d78	52		 push	 edx
  00d79	ff 71 60	 push	 DWORD PTR [ecx+96]
  00d7c	89 55 cc	 mov	 DWORD PTR tv2790[ebp], edx
  00d7f	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00d82	b9 01 00 00 00	 mov	 ecx, 1
  00d87	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  00d8d	89 7d d0	 mov	 DWORD PTR tv2786[ebp], edi
  00d90	e8 00 00 00 00	 call	 _inflate_table

; 1002 :             if (ret) {

  00d95	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1003 :                 strm->msg = (char *)"invalid literal/lengths set";
; 1004 :                 state->mode = BAD;

  00d98	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d9b	83 c4 10	 add	 esp, 16			; 00000010H
  00d9e	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00da1	85 c0		 test	 eax, eax
  00da3	74 12		 je	 SHORT $LN150@inflate

; 1005 :                 break;

  00da5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00da8	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00dab	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00db2	e9 e7 06 00 00	 jmp	 $LN831@inflate
$LN150@inflate:

; 1006 :             }
; 1007 :             state->distcode = (const code FAR *)(state->next);

  00db7	8b 55 cc	 mov	 edx, DWORD PTR tv2790[ebp]

; 1008 :             state->distbits = 6;
; 1009 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1010 :                             &(state->next), &(state->distbits), state->work);

  00dba	ff 75 d0	 push	 DWORD PTR tv2786[ebp]
  00dbd	8b 02		 mov	 eax, DWORD PTR [edx]
  00dbf	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00dc2	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00dc5	50		 push	 eax
  00dc6	52		 push	 edx
  00dc7	ff 71 64	 push	 DWORD PTR [ecx+100]
  00dca	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  00dd0	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00dd3	83 c1 70	 add	 ecx, 112		; 00000070H
  00dd6	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00dd9	b9 02 00 00 00	 mov	 ecx, 2
  00dde	e8 00 00 00 00	 call	 _inflate_table

; 1011 :             if (ret) {
; 1012 :                 strm->msg = (char *)"invalid distances set";
; 1013 :                 state->mode = BAD;

  00de3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00de6	83 c4 10	 add	 esp, 16			; 00000010H
  00de9	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00dec	85 c0		 test	 eax, eax
  00dee	74 12		 je	 SHORT $LN149@inflate

; 1014 :                 break;

  00df0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00df3	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00df6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00dfd	e9 9c 06 00 00	 jmp	 $LN831@inflate
$LN149@inflate:

; 1015 :             }
; 1016 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1017 :             state->mode = LEN_;
; 1018 :             if (flush == Z_TREES) goto inf_leave;

  00e02	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00e05	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00e0b	83 fa 06	 cmp	 edx, 6
  00e0e	0f 84 fb 06 00
	00		 je	 $LN768@inflate
  00e14	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN148@inflate:

; 1019 :         case LEN_:
; 1020 :             state->mode = LEN;

  00e17	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN146@inflate:

; 1021 :         case LEN:
; 1022 :             if (have >= 6 && left >= 258) {

  00e1d	83 fb 06	 cmp	 ebx, 6
  00e20	72 73		 jb	 SHORT $LN145@inflate
  00e22	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00e29	72 6a		 jb	 SHORT $LN145@inflate

; 1023 :                 RESTORE();

  00e2b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e2e	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1024 :                 inflate_fast(strm, out);

  00e31	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  00e34	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00e37	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00e3a	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00e3d	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e40	89 38		 mov	 DWORD PTR [eax], edi
  00e42	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00e45	50		 push	 eax
  00e46	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  00e49	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00e4c	e8 00 00 00 00	 call	 _inflate_fast

; 1025 :                 LOAD();

  00e51	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e54	83 c4 08	 add	 esp, 8
  00e57	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00e5a	8b 38		 mov	 edi, DWORD PTR [eax]
  00e5c	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00e5f	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00e62	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00e65	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00e68	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e6b	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 1026 :                 if (state->mode == TYPE)

  00e6e	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  00e71	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00e74	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00e77	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00e7a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00e7d	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00e80	0f 85 1e 06 00
	00		 jne	 $LN490@inflate

; 1027 :                     state->back = -1;

  00e86	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1028 :                 break;

  00e90	e9 0f 06 00 00	 jmp	 $LN490@inflate
$LN145@inflate:

; 1029 :             }
; 1030 :             state->back = 0;

  00e95	c7 81 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7108], 0

; 1031 :             for (;;) {
; 1032 :                 here = state->lencode[BITS(state->lenbits)];

  00e9f	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00ea2	b8 01 00 00 00	 mov	 eax, 1
  00ea7	d3 e0		 shl	 eax, cl
  00ea9	48		 dec	 eax
  00eaa	89 45 d0	 mov	 DWORD PTR tv2784[ebp], eax
  00ead	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00eb0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00eb3	8b 45 d0	 mov	 eax, DWORD PTR tv2784[ebp]
  00eb6	23 c2		 and	 eax, edx
  00eb8	89 4d cc	 mov	 DWORD PTR tv2782[ebp], ecx
  00ebb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1033 :                 if ((unsigned)(here.bits) <= bits) break;

  00ebe	8b c8		 mov	 ecx, eax
  00ec0	c1 e9 08	 shr	 ecx, 8
  00ec3	0f b6 c9	 movzx	 ecx, cl
  00ec6	3b ce		 cmp	 ecx, esi
  00ec8	76 3c		 jbe	 SHORT $LN562@inflate
  00eca	8d 9b 00 00 00
	00		 npad	 6
$LL137@inflate:

; 1034 :                 PULLBYTE();

  00ed0	85 db		 test	 ebx, ebx
  00ed2	0f 84 7d f6 ff
	ff		 je	 $LN792@inflate
  00ed8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00edb	8b ce		 mov	 ecx, esi
  00edd	d3 e0		 shl	 eax, cl
  00edf	8b 4d cc	 mov	 ecx, DWORD PTR tv2782[ebp]
  00ee2	4b		 dec	 ebx
  00ee3	47		 inc	 edi
  00ee4	03 d0		 add	 edx, eax
  00ee6	8b 45 d0	 mov	 eax, DWORD PTR tv2784[ebp]
  00ee9	23 c2		 and	 eax, edx
  00eeb	83 c6 08	 add	 esi, 8
  00eee	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ef1	8b c8		 mov	 ecx, eax
  00ef3	c1 e9 08	 shr	 ecx, 8
  00ef6	0f b6 c9	 movzx	 ecx, cl
  00ef9	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00efc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00eff	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f02	3b ce		 cmp	 ecx, esi
  00f04	77 ca		 ja	 SHORT $LL137@inflate
$LN562@inflate:

; 1035 :             }
; 1036 :             if (here.op && (here.op & 0xf0) == 0) {

  00f06	84 c0		 test	 al, al
  00f08	0f 84 bc 00 00
	00		 je	 $LN119@inflate
  00f0e	a8 f0		 test	 al, 240			; 000000f0H
  00f10	0f 85 b4 00 00
	00		 jne	 $LN119@inflate

; 1037 :                 last = here;
; 1038 :                 for (;;) {
; 1039 :                     here = state->lencode[last.val +
; 1040 :                             (BITS(last.bits + last.op) >> last.bits)];

  00f16	8b c8		 mov	 ecx, eax
  00f18	c1 e9 08	 shr	 ecx, 8
  00f1b	0f b6 f9	 movzx	 edi, cl
  00f1e	89 4d d8	 mov	 DWORD PTR tv2781[ebp], ecx
  00f21	0f b6 c8	 movzx	 ecx, al
  00f24	03 cf		 add	 ecx, edi
  00f26	bb 01 00 00 00	 mov	 ebx, 1
  00f2b	d3 e3		 shl	 ebx, cl
  00f2d	8b cf		 mov	 ecx, edi
  00f2f	8b d0		 mov	 edx, eax
  00f31	c1 e8 10	 shr	 eax, 16			; 00000010H
  00f34	4b		 dec	 ebx
  00f35	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00f38	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  00f3b	d3 eb		 shr	 ebx, cl
  00f3d	8b 4d cc	 mov	 ecx, DWORD PTR tv2782[ebp]
  00f40	03 d8		 add	 ebx, eax
  00f42	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1041 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00f45	8b c8		 mov	 ecx, eax
  00f47	c1 e9 08	 shr	 ecx, 8
  00f4a	0f b6 f9	 movzx	 edi, cl
  00f4d	8b 4d d8	 mov	 ecx, DWORD PTR tv2781[ebp]
  00f50	0f b6 c9	 movzx	 ecx, cl
  00f53	03 f9		 add	 edi, ecx
  00f55	3b fe		 cmp	 edi, esi
  00f57	76 5b		 jbe	 SHORT $LN122@inflate
  00f59	8d a4 24 00 00
	00 00		 npad	 7
$LL129@inflate:

; 1042 :                     PULLBYTE();

  00f60	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  00f63	85 c0		 test	 eax, eax
  00f65	0f 84 ed f5 ff
	ff		 je	 $LN799@inflate
  00f6b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00f6e	48		 dec	 eax
  00f6f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  00f72	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00f75	8b ce		 mov	 ecx, esi
  00f77	d3 e0		 shl	 eax, cl
  00f79	43		 inc	 ebx
  00f7a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00f7d	0f b6 de	 movzx	 ebx, dh
  00f80	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00f83	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  00f87	0f b6 ca	 movzx	 ecx, dl
  00f8a	03 cb		 add	 ecx, ebx
  00f8c	bf 01 00 00 00	 mov	 edi, 1
  00f91	d3 e7		 shl	 edi, cl
  00f93	8b cb		 mov	 ecx, ebx
  00f95	83 c6 08	 add	 esi, 8
  00f98	4f		 dec	 edi
  00f99	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  00f9c	d3 ef		 shr	 edi, cl
  00f9e	03 f8		 add	 edi, eax
  00fa0	8b 45 cc	 mov	 eax, DWORD PTR tv2782[ebp]
  00fa3	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00fa6	8b c8		 mov	 ecx, eax
  00fa8	c1 e9 08	 shr	 ecx, 8
  00fab	0f b6 c9	 movzx	 ecx, cl
  00fae	03 cb		 add	 ecx, ebx
  00fb0	3b ce		 cmp	 ecx, esi
  00fb2	77 ac		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1043 :                 }
; 1044 :                 DROPBITS(last.bits);
; 1045 :                 state->back += last.bits;

  00fb4	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00fb7	0f b6 ce	 movzx	 ecx, dh
  00fba	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00fbd	d3 ea		 shr	 edx, cl
  00fbf	89 8b c4 1b 00
	00		 mov	 DWORD PTR [ebx+7108], ecx
  00fc5	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00fc8	2b f1		 sub	 esi, ecx
$LN119@inflate:

; 1046 :             }
; 1047 :             DROPBITS(here.bits);
; 1048 :             state->back += here.bits;

  00fca	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00fcd	8b c8		 mov	 ecx, eax
  00fcf	c1 e9 08	 shr	 ecx, 8
  00fd2	0f b6 c9	 movzx	 ecx, cl
  00fd5	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
  00fdb	d3 ea		 shr	 edx, cl
  00fdd	2b f1		 sub	 esi, ecx

; 1049 :             state->length = (unsigned)here.val;

  00fdf	8b c8		 mov	 ecx, eax
  00fe1	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00fe4	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1050 :             if ((int)(here.op) == 0) {

  00fe7	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1051 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1052 :                         "inflate:         literal '%c'\n" :
; 1053 :                         "inflate:         literal 0x%02x\n", here.val));
; 1054 :                 state->mode = LIT;

  00fea	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00fed	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ff0	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ff3	84 c0		 test	 al, al
  00ff5	75 0b		 jne	 SHORT $LN116@inflate
  00ff7	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1055 :                 break;

  00ffd	e9 a2 04 00 00	 jmp	 $LN490@inflate
$LN116@inflate:

; 1056 :             }
; 1057 :             if (here.op & 32) {

  01002	a8 20		 test	 al, 32			; 00000020H
  01004	74 15		 je	 SHORT $LN115@inflate

; 1058 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1059 :                 state->back = -1;

  01006	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1
$LN263@inflate:

; 1060 :                 state->mode = TYPE;

  01010	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1061 :                 break;

  01016	e9 89 04 00 00	 jmp	 $LN490@inflate
$LN115@inflate:

; 1062 :             }
; 1063 :             if (here.op & 64) {

  0101b	a8 40		 test	 al, 64			; 00000040H
  0101d	74 0f		 je	 SHORT $LN114@inflate

; 1064 :                 strm->msg = (char *)"invalid literal/length code";

  0101f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01022	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1065 :                 state->mode = BAD;
; 1066 :                 break;

  01029	e9 70 04 00 00	 jmp	 $LN831@inflate
$LN114@inflate:

; 1067 :             }
; 1068 :             state->extra = (unsigned)(here.op) & 15;

  0102e	0f b6 c0	 movzx	 eax, al
  01031	83 e0 0f	 and	 eax, 15			; 0000000fH
  01034	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1069 :             state->mode = LENEXT;

  01037	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
$LN113@inflate:

; 1070 :         case LENEXT:
; 1071 :             if (state->extra) {

  0103d	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01040	89 45 cc	 mov	 DWORD PTR tv2758[ebp], eax
  01043	85 c0		 test	 eax, eax
  01045	74 55		 je	 SHORT $LN112@inflate

; 1072 :                 NEEDBITS(state->extra);

  01047	3b f0		 cmp	 esi, eax
  01049	73 29		 jae	 SHORT $LN110@inflate
  0104b	eb 03 8d 49 00	 npad	 5
$LL108@inflate:
  01050	85 db		 test	 ebx, ebx
  01052	0f 84 fd f4 ff
	ff		 je	 $LN792@inflate
  01058	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0105b	8b ce		 mov	 ecx, esi
  0105d	d3 e0		 shl	 eax, cl
  0105f	4b		 dec	 ebx
  01060	47		 inc	 edi
  01061	83 c6 08	 add	 esi, 8
  01064	03 d0		 add	 edx, eax
  01066	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01069	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0106c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0106f	3b 75 cc	 cmp	 esi, DWORD PTR tv2758[ebp]
  01072	72 dc		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1073 :                 state->length += BITS(state->extra);

  01074	8b 4d cc	 mov	 ecx, DWORD PTR tv2758[ebp]
  01077	b8 01 00 00 00	 mov	 eax, 1
  0107c	d3 e0		 shl	 eax, cl
  0107e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01081	48		 dec	 eax
  01082	23 c2		 and	 eax, edx
  01084	01 41 40	 add	 DWORD PTR [ecx+64], eax

; 1074 :                 DROPBITS(state->extra);

  01087	8b 45 cc	 mov	 eax, DWORD PTR tv2758[ebp]
  0108a	8b c8		 mov	 ecx, eax
  0108c	d3 ea		 shr	 edx, cl

; 1075 :                 state->back += state->extra;

  0108e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01091	2b f0		 sub	 esi, eax
  01093	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
  01099	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN112@inflate:

; 1076 :             }
; 1077 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1078 :             state->was = state->length;

  0109c	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0109f	89 81 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], eax

; 1079 :             state->mode = DIST;

  010a5	c7 01 16 00 00
	00		 mov	 DWORD PTR [ecx], 22	; 00000016H
$LN537@inflate:

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  010ab	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  010ae	b8 01 00 00 00	 mov	 eax, 1
  010b3	d3 e0		 shl	 eax, cl
  010b5	48		 dec	 eax
  010b6	89 45 d0	 mov	 DWORD PTR tv2756[ebp], eax
  010b9	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  010bc	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  010bf	8b 45 d0	 mov	 eax, DWORD PTR tv2756[ebp]
  010c2	23 c2		 and	 eax, edx
  010c4	89 4d cc	 mov	 DWORD PTR tv2755[ebp], ecx
  010c7	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1083 :                 if ((unsigned)(here.bits) <= bits) break;

  010ca	8b c8		 mov	 ecx, eax
  010cc	c1 e9 08	 shr	 ecx, 8
  010cf	0f b6 c9	 movzx	 ecx, cl
  010d2	3b ce		 cmp	 ecx, esi
  010d4	76 36		 jbe	 SHORT $LN567@inflate
$LL98@inflate:

; 1084 :                 PULLBYTE();

  010d6	85 db		 test	 ebx, ebx
  010d8	0f 84 77 f4 ff
	ff		 je	 $LN792@inflate
  010de	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  010e1	8b ce		 mov	 ecx, esi
  010e3	d3 e0		 shl	 eax, cl
  010e5	8b 4d cc	 mov	 ecx, DWORD PTR tv2755[ebp]
  010e8	4b		 dec	 ebx
  010e9	47		 inc	 edi
  010ea	03 d0		 add	 edx, eax
  010ec	8b 45 d0	 mov	 eax, DWORD PTR tv2756[ebp]
  010ef	23 c2		 and	 eax, edx
  010f1	83 c6 08	 add	 esi, 8
  010f4	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  010f7	8b c8		 mov	 ecx, eax
  010f9	c1 e9 08	 shr	 ecx, 8
  010fc	0f b6 c9	 movzx	 ecx, cl
  010ff	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01102	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01105	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01108	3b ce		 cmp	 ecx, esi
  0110a	77 ca		 ja	 SHORT $LL98@inflate
$LN567@inflate:

; 1085 :             }
; 1086 :             if ((here.op & 0xf0) == 0) {

  0110c	a8 f0		 test	 al, 240			; 000000f0H
  0110e	0f 85 b5 00 00
	00		 jne	 $LN794@inflate

; 1087 :                 last = here;
; 1088 :                 for (;;) {
; 1089 :                     here = state->distcode[last.val +
; 1090 :                             (BITS(last.bits + last.op) >> last.bits)];

  01114	8b c8		 mov	 ecx, eax
  01116	c1 e9 08	 shr	 ecx, 8
  01119	0f b6 f9	 movzx	 edi, cl
  0111c	89 4d d8	 mov	 DWORD PTR tv2779[ebp], ecx
  0111f	0f b6 c8	 movzx	 ecx, al
  01122	03 cf		 add	 ecx, edi
  01124	bb 01 00 00 00	 mov	 ebx, 1
  01129	d3 e3		 shl	 ebx, cl
  0112b	8b cf		 mov	 ecx, edi
  0112d	8b d0		 mov	 edx, eax
  0112f	c1 e8 10	 shr	 eax, 16			; 00000010H
  01132	4b		 dec	 ebx
  01133	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  01136	89 55 d0	 mov	 DWORD PTR _last$[ebp], edx
  01139	d3 eb		 shr	 ebx, cl
  0113b	8b 4d cc	 mov	 ecx, DWORD PTR tv2755[ebp]
  0113e	03 d8		 add	 ebx, eax
  01140	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1091 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01143	8b c8		 mov	 ecx, eax
  01145	c1 e9 08	 shr	 ecx, 8
  01148	0f b6 f9	 movzx	 edi, cl
  0114b	8b 4d d8	 mov	 ecx, DWORD PTR tv2779[ebp]
  0114e	0f b6 c9	 movzx	 ecx, cl
  01151	03 f9		 add	 edi, ecx
  01153	3b fe		 cmp	 edi, esi
  01155	76 5d		 jbe	 SHORT $LN83@inflate
  01157	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL90@inflate:

; 1092 :                     PULLBYTE();

  01160	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01163	85 c0		 test	 eax, eax
  01165	0f 84 ed f3 ff
	ff		 je	 $LN799@inflate
  0116b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0116e	48		 dec	 eax
  0116f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01172	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01175	8b ce		 mov	 ecx, esi
  01177	d3 e0		 shl	 eax, cl
  01179	43		 inc	 ebx
  0117a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0117d	0f b6 de	 movzx	 ebx, dh
  01180	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01183	0f b7 45 d2	 movzx	 eax, WORD PTR _last$[ebp+2]
  01187	0f b6 ca	 movzx	 ecx, dl
  0118a	03 cb		 add	 ecx, ebx
  0118c	bf 01 00 00 00	 mov	 edi, 1
  01191	d3 e7		 shl	 edi, cl
  01193	8b cb		 mov	 ecx, ebx
  01195	83 c6 08	 add	 esi, 8
  01198	4f		 dec	 edi
  01199	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0119c	d3 ef		 shr	 edi, cl
  0119e	03 f8		 add	 edi, eax
  011a0	8b 45 cc	 mov	 eax, DWORD PTR tv2755[ebp]
  011a3	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  011a6	8b c8		 mov	 ecx, eax
  011a8	c1 e9 08	 shr	 ecx, 8
  011ab	0f b6 c9	 movzx	 ecx, cl
  011ae	03 cb		 add	 ecx, ebx
  011b0	3b ce		 cmp	 ecx, esi
  011b2	77 ac		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1093 :                 }
; 1094 :                 DROPBITS(last.bits);
; 1095 :                 state->back += last.bits;

  011b4	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  011b7	0f b6 ce	 movzx	 ecx, dh
  011ba	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  011bd	d3 ea		 shr	 edx, cl
  011bf	2b f1		 sub	 esi, ecx
  011c1	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  011c7	eb 03		 jmp	 SHORT $LN80@inflate
$LN794@inflate:
  011c9	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN80@inflate:

; 1102 :                 break;

  011cc	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  011cf	8b c8		 mov	 ecx, eax
  011d1	c1 e9 08	 shr	 ecx, 8
  011d4	0f b6 c9	 movzx	 ecx, cl
  011d7	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  011dd	d3 ea		 shr	 edx, cl
  011df	2b f1		 sub	 esi, ecx
  011e1	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  011e4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  011e7	a8 40		 test	 al, 64			; 00000040H
  011e9	74 15		 je	 SHORT $LN77@inflate

; 1096 :             }
; 1097 :             DROPBITS(here.bits);
; 1098 :             state->back += here.bits;
; 1099 :             if (here.op & 64) {
; 1100 :                 strm->msg = (char *)"invalid distance code";
; 1101 :                 state->mode = BAD;

  011eb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  011ee	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1102 :                 break;

  011f1	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  011f4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  011fb	e9 9e 02 00 00	 jmp	 $LN831@inflate
$LN77@inflate:

; 1103 :             }
; 1104 :             state->offset = (unsigned)here.val;

  01200	8b c8		 mov	 ecx, eax
  01202	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 1105 :             state->extra = (unsigned)(here.op) & 15;

  01205	0f b6 c0	 movzx	 eax, al
  01208	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  0120b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0120e	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01211	83 e0 0f	 and	 eax, 15			; 0000000fH
  01214	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1106 :             state->mode = DISTEXT;

  01217	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN76@inflate:

; 1107 :         case DISTEXT:
; 1108 :             if (state->extra) {

  0121d	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01220	89 45 cc	 mov	 DWORD PTR tv2757[ebp], eax
  01223	85 c0		 test	 eax, eax
  01225	74 58		 je	 SHORT $LN75@inflate

; 1109 :                 NEEDBITS(state->extra);

  01227	3b f0		 cmp	 esi, eax
  01229	73 29		 jae	 SHORT $LN73@inflate
  0122b	eb 03 8d 49 00	 npad	 5
$LL71@inflate:
  01230	85 db		 test	 ebx, ebx
  01232	0f 84 1d f3 ff
	ff		 je	 $LN792@inflate
  01238	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0123b	8b ce		 mov	 ecx, esi
  0123d	d3 e0		 shl	 eax, cl
  0123f	4b		 dec	 ebx
  01240	47		 inc	 edi
  01241	83 c6 08	 add	 esi, 8
  01244	03 d0		 add	 edx, eax
  01246	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01249	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0124c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0124f	3b 75 cc	 cmp	 esi, DWORD PTR tv2757[ebp]
  01252	72 dc		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1110 :                 state->offset += BITS(state->extra);

  01254	8b 4d cc	 mov	 ecx, DWORD PTR tv2757[ebp]
  01257	b8 01 00 00 00	 mov	 eax, 1
  0125c	d3 e0		 shl	 eax, cl
  0125e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01261	48		 dec	 eax
  01262	23 c2		 and	 eax, edx
  01264	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1111 :                 DROPBITS(state->extra);

  01267	8b 45 cc	 mov	 eax, DWORD PTR tv2757[ebp]
  0126a	8b c8		 mov	 ecx, eax
  0126c	d3 ea		 shr	 edx, cl

; 1112 :                 state->back += state->extra;

  0126e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01271	2b f0		 sub	 esi, eax
  01273	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
  01279	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0127c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN75@inflate:

; 1113 :             }
; 1114 : #ifdef INFLATE_STRICT
; 1115 :             if (state->offset > state->dmax) {
; 1116 :                 strm->msg = (char *)"invalid distance too far back";
; 1117 :                 state->mode = BAD;
; 1118 :                 break;
; 1119 :             }
; 1120 : #endif
; 1121 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1122 :             state->mode = MATCH;

  0127f	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H
$LN62@inflate:

; 1123 :         case MATCH:
; 1124 :             if (left == 0) goto inf_leave;

  01285	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01289	0f 84 c6 f2 ff
	ff		 je	 $LN792@inflate

; 1125 :             copy = out - left;

  0128f	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01292	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01295	89 45 cc	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1126 :             if (state->offset > copy) {         /* copy from window */

  01298	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0129b	3b 45 cc	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  0129e	76 4e		 jbe	 SHORT $LN60@inflate

; 1127 :                 copy = state->offset - copy;

  012a0	2b 45 cc	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1128 :                 if (copy > state->whave) {

  012a3	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  012a6	76 18		 jbe	 SHORT $LN58@inflate

; 1129 :                     if (state->sane) {

  012a8	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  012af	74 0f		 je	 SHORT $LN58@inflate

; 1130 :                         strm->msg = (char *)"invalid distance too far back";

  012b1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  012b4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1131 :                         state->mode = BAD;
; 1132 :                         break;

  012bb	e9 de 01 00 00	 jmp	 $LN831@inflate
$LN58@inflate:

; 1133 :                     }
; 1134 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1135 :                     Trace((stderr, "inflate.c too far\n"));
; 1136 :                     copy -= state->whave;
; 1137 :                     if (copy > state->length) copy = state->length;
; 1138 :                     if (copy > left) copy = left;
; 1139 :                     left -= copy;
; 1140 :                     state->length -= copy;
; 1141 :                     do {
; 1142 :                         *put++ = 0;
; 1143 :                     } while (--copy);
; 1144 :                     if (state->length == 0) state->mode = LEN;
; 1145 :                     break;
; 1146 : #endif
; 1147 :                 }
; 1148 :                 if (copy > state->wnext) {

  012c0	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  012c3	76 10		 jbe	 SHORT $LN57@inflate

; 1149 :                     copy -= state->wnext;
; 1150 :                     from = state->window + (state->wsize - copy);

  012c5	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  012c8	2b 41 30	 sub	 eax, DWORD PTR [ecx+48]
  012cb	03 79 28	 add	 edi, DWORD PTR [ecx+40]
  012ce	2b f8		 sub	 edi, eax
  012d0	89 7d d8	 mov	 DWORD PTR _from$1$[ebp], edi

; 1151 :                 }
; 1152 :                 else

  012d3	eb 0b		 jmp	 SHORT $LN56@inflate
$LN57@inflate:

; 1153 :                     from = state->window + (state->wnext - copy);

  012d5	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  012d8	2b d8		 sub	 ebx, eax
  012da	03 59 30	 add	 ebx, DWORD PTR [ecx+48]
  012dd	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN56@inflate:

; 1154 :                 if (copy > state->length) copy = state->length;

  012e0	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  012e3	89 7d cc	 mov	 DWORD PTR tv2716[ebp], edi
  012e6	3b c7		 cmp	 eax, edi
  012e8	76 13		 jbe	 SHORT $LN54@inflate
  012ea	8b c7		 mov	 eax, edi

; 1155 :             }
; 1156 :             else {                              /* copy from output */

  012ec	eb 0f		 jmp	 SHORT $LN54@inflate
$LN60@inflate:

; 1157 :                 from = put - state->offset;

  012ee	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  012f1	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
  012f4	29 45 d8	 sub	 DWORD PTR _from$1$[ebp], eax

; 1158 :                 copy = state->length;

  012f7	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  012fa	89 45 cc	 mov	 DWORD PTR tv2716[ebp], eax
$LN54@inflate:

; 1159 :             }
; 1160 :             if (copy > left) copy = left;

  012fd	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  01300	3b c3		 cmp	 eax, ebx
  01302	0f 47 c3	 cmova	 eax, ebx

; 1161 :             left -= copy;

  01305	2b d8		 sub	 ebx, eax
  01307	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx

; 1162 :             state->length -= copy;

  0130a	8b 5d cc	 mov	 ebx, DWORD PTR tv2716[ebp]
  0130d	2b d8		 sub	 ebx, eax
  0130f	89 59 40	 mov	 DWORD PTR [ecx+64], ebx

; 1165 :             } while (--copy);

  01312	8b 5d d8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01315	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01318	89 45 d0	 mov	 DWORD PTR _copy$11$[ebp], eax
  0131b	2b d9		 sub	 ebx, ecx
  0131d	8b f8		 mov	 edi, eax
  0131f	90		 npad	 1
$LL52@inflate:

; 1163 :             do {
; 1164 :                 *put++ = *from++;

  01320	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01323	88 01		 mov	 BYTE PTR [ecx], al
  01325	41		 inc	 ecx

; 1165 :             } while (--copy);

  01326	4f		 dec	 edi
  01327	75 f7		 jne	 SHORT $LL52@inflate

; 1166 :             if (state->length == 0) state->mode = LEN;

  01329	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0132c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0132f	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  01332	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01335	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  01339	0f 85 65 01 00
	00		 jne	 $LN490@inflate
  0133f	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 1167 :             break;

  01345	e9 5a 01 00 00	 jmp	 $LN490@inflate
$LN48@inflate:

; 1168 :         case LIT:
; 1169 :             if (left == 0) goto inf_leave;

  0134a	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0134e	0f 84 01 f2 ff
	ff		 je	 $LN792@inflate

; 1170 :             *put++ = (unsigned char)(state->length);

  01354	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  01357	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  0135a	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1171 :             left--;

  0135d	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01360	88 07		 mov	 BYTE PTR [edi], al

; 1172 :             state->mode = LEN;
; 1173 :             break;

  01362	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01365	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  0136b	e9 34 01 00 00	 jmp	 $LN490@inflate
$LN46@inflate:

; 1174 :         case CHECK:
; 1175 :             if (state->wrap) {

  01370	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  01374	0f 84 cc 00 00
	00		 je	 $LN31@inflate

; 1176 :                 NEEDBITS(32);

  0137a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0137d	73 2b		 jae	 SHORT $LN43@inflate
  0137f	90		 npad	 1
$LL41@inflate:
  01380	85 db		 test	 ebx, ebx
  01382	0f 84 cd f1 ff
	ff		 je	 $LN792@inflate
  01388	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0138b	8b ce		 mov	 ecx, esi
  0138d	d3 e0		 shl	 eax, cl
  0138f	83 c6 08	 add	 esi, 8
  01392	4b		 dec	 ebx
  01393	47		 inc	 edi
  01394	03 d0		 add	 edx, eax
  01396	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01399	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0139c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0139f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  013a2	83 fe 20	 cmp	 esi, 32			; 00000020H
  013a5	72 d9		 jb	 SHORT $LL41@inflate
  013a7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN43@inflate:

; 1177 :                 out -= left;

  013aa	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  013ad	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1178 :                 strm->total_out += out;

  013b0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  013b3	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  013b6	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1179 :                 state->total += out;

  013b9	8b c7		 mov	 eax, edi
  013bb	01 41 1c	 add	 DWORD PTR [ecx+28], eax

; 1180 :                 if (out)

  013be	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013c1	85 c0		 test	 eax, eax
  013c3	74 2c		 je	 SHORT $LN35@inflate

; 1181 :                     strm->adler = state->check =
; 1182 :                         UPDATE(state->check, put - out, out);

  013c5	50		 push	 eax
  013c6	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  013c9	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  013cc	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  013d0	50		 push	 eax
  013d1	ff 71 18	 push	 DWORD PTR [ecx+24]
  013d4	74 07		 je	 SHORT $LN504@inflate
  013d6	e8 00 00 00 00	 call	 _crc32@12
  013db	eb 05		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  013dd	e8 00 00 00 00	 call	 _adler32@12
$LN505@inflate:
  013e2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013e5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  013e8	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  013eb	89 42 30	 mov	 DWORD PTR [edx+48], eax
  013ee	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN35@inflate:

; 1183 :                 out = left;
; 1184 :                 if ((
; 1185 : #ifdef GUNZIP
; 1186 :                      state->flags ? hold :
; 1187 : #endif
; 1188 :                      ZSWAP32(hold)) != state->check) {

  013f1	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  013f5	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  013f8	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  013fb	8b c2		 mov	 eax, edx
  013fd	75 2c		 jne	 SHORT $LN507@inflate
  013ff	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01404	89 45 d8	 mov	 DWORD PTR tv2877[ebp], eax
  01407	8b c2		 mov	 eax, edx
  01409	c1 e0 10	 shl	 eax, 16			; 00000010H
  0140c	01 45 d8	 add	 DWORD PTR tv2877[ebp], eax
  0140f	c1 65 d8 08	 shl	 DWORD PTR tv2877[ebp], 8
  01413	8b c2		 mov	 eax, edx
  01415	c1 e8 08	 shr	 eax, 8
  01418	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0141d	01 45 d8	 add	 DWORD PTR tv2877[ebp], eax
  01420	8b c2		 mov	 eax, edx
  01422	c1 e8 18	 shr	 eax, 24			; 00000018H
  01425	01 45 d8	 add	 DWORD PTR tv2877[ebp], eax
  01428	8b 45 d8	 mov	 eax, DWORD PTR tv2877[ebp]
$LN507@inflate:
  0142b	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  0142e	74 0c		 je	 SHORT $LN33@inflate

; 1189 :                     strm->msg = (char *)"incorrect data check";

  01430	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01433	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1190 :                     state->mode = BAD;
; 1191 :                     break;

  0143a	eb 62		 jmp	 SHORT $LN831@inflate
$LN33@inflate:

; 1192 :                 }
; 1193 :                 INITBITS();

  0143c	33 d2		 xor	 edx, edx
  0143e	33 f6		 xor	 esi, esi
  01440	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01443	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN31@inflate:

; 1194 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1195 :             }
; 1196 : #ifdef GUNZIP
; 1197 :             state->mode = LENGTH;

  01446	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH
$LN30@inflate:

; 1198 :         case LENGTH:
; 1199 :             if (state->wrap && state->flags) {

  0144c	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  01450	0f 84 9b 00 00
	00		 je	 $LN16@inflate
  01456	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0145a	0f 84 91 00 00
	00		 je	 $LN16@inflate

; 1200 :                 NEEDBITS(32);

  01460	83 fe 20	 cmp	 esi, 32			; 00000020H
  01463	73 2a		 jae	 SHORT $LN27@inflate
$LL25@inflate:
  01465	85 db		 test	 ebx, ebx
  01467	0f 84 e8 f0 ff
	ff		 je	 $LN792@inflate
  0146d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01470	8b ce		 mov	 ecx, esi
  01472	d3 e0		 shl	 eax, cl
  01474	83 c6 08	 add	 esi, 8
  01477	4b		 dec	 ebx
  01478	47		 inc	 edi
  01479	03 d0		 add	 edx, eax
  0147b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0147e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01481	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01484	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01487	83 fe 20	 cmp	 esi, 32			; 00000020H
  0148a	72 d9		 jb	 SHORT $LL25@inflate
  0148c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN27@inflate:

; 1201 :                 if (hold != (state->total & 0xffffffffUL)) {

  0148f	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01492	74 54		 je	 SHORT $LN18@inflate

; 1202 :                     strm->msg = (char *)"incorrect length check";

  01494	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01497	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
$LN831@inflate:

; 1203 :                     state->mode = BAD;

  0149e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN490@inflate:

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  014a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  014a6	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  014a9	0f 86 d3 eb ff
	ff		 jbe	 $LL493@inflate
$LN12@inflate:
  014af	5f		 pop	 edi
  014b0	5e		 pop	 esi

; 1216 :             goto inf_leave;
; 1217 :         case MEM:
; 1218 :             return Z_MEM_ERROR;
; 1219 :         case SYNC:
; 1220 :         default:
; 1221 :             return Z_STREAM_ERROR;

  014b1	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  014b6	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  014b7	8b e5		 mov	 esp, ebp
  014b9	5d		 pop	 ebp
  014ba	c2 08 00	 ret	 8
$LN579@inflate:

; 821  :                 RESTORE();

  014bd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014c0	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  014c3	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  014c6	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  014c9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  014cc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014cf	89 38		 mov	 DWORD PTR [eax], edi
  014d1	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  014d4	5f		 pop	 edi
  014d5	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  014d8	5e		 pop	 esi
  014d9	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 822  :                 return Z_NEED_DICT;

  014dc	b8 02 00 00 00	 mov	 eax, 2
  014e1	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  014e2	8b e5		 mov	 esp, ebp
  014e4	5d		 pop	 ebp
  014e5	c2 08 00	 ret	 8
$LN18@inflate:

; 1204 :                     break;
; 1205 :                 }
; 1206 :                 INITBITS();

  014e8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  014ef	33 f6		 xor	 esi, esi
$LN16@inflate:

; 1207 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1208 :             }
; 1209 : #endif
; 1210 :             state->mode = DONE;

  014f1	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH
$LN15@inflate:

; 1211 :         case DONE:
; 1212 :             ret = Z_STREAM_END;

  014f7	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1213 :             goto inf_leave;

  014fe	e9 52 f0 ff ff	 jmp	 $LN792@inflate
$LN14@inflate:

; 1214 :         case BAD:
; 1215 :             ret = Z_DATA_ERROR;

  01503	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  0150a	e9 46 f0 ff ff	 jmp	 $LN792@inflate
$LN768@inflate:
  0150f	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01512	e9 44 f0 ff ff	 jmp	 $inf_leave$839
$LN5@inflate:

; 1237 :         }
; 1238 :     in -= strm->avail_in;

  01517	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0151a	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1239 :     out -= strm->avail_out;

  0151d	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1240 :     strm->total_in += in;

  01520	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1241 :     strm->total_out += out;

  01523	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1242 :     state->total += out;

  01526	01 73 1c	 add	 DWORD PTR [ebx+28], esi

; 1243 :     if (state->wrap && out)

  01529	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0152d	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  01530	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  01533	74 26		 je	 SHORT $LN4@inflate
  01535	85 f6		 test	 esi, esi
  01537	74 22		 je	 SHORT $LN4@inflate

; 1244 :         strm->adler = state->check =
; 1245 :             UPDATE(state->check, strm->next_out - out, out);

  01539	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0153c	56		 push	 esi
  0153d	2b c6		 sub	 eax, esi
  0153f	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  01543	50		 push	 eax
  01544	ff 73 18	 push	 DWORD PTR [ebx+24]
  01547	74 07		 je	 SHORT $LN508@inflate
  01549	e8 00 00 00 00	 call	 _crc32@12
  0154e	eb 05		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  01550	e8 00 00 00 00	 call	 _adler32@12
$LN509@inflate:
  01555	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  01558	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN4@inflate:

; 1246 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1247 :                       (state->mode == TYPE ? 128 : 0) +
; 1248 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  0155b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0155d	83 fa 13	 cmp	 edx, 19			; 00000013H
  01560	74 09		 je	 SHORT $LN510@inflate
  01562	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  01565	74 04		 je	 SHORT $LN510@inflate
  01567	33 f6		 xor	 esi, esi
  01569	eb 05		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  0156b	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN511@inflate:
  01570	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  01573	f7 d9		 neg	 ecx
  01575	1b c9		 sbb	 ecx, ecx
  01577	33 c0		 xor	 eax, eax
  01579	83 e1 40	 and	 ecx, 64			; 00000040H
  0157c	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0157f	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2740[ebp], 128 ; 00000080H
  01586	0f 44 45 08	 cmove	 eax, DWORD PTR tv2740[ebp]
  0158a	03 ce		 add	 ecx, esi
  0158c	03 c1		 add	 eax, ecx
  0158e	03 43 3c	 add	 eax, DWORD PTR [ebx+60]
  01591	89 47 2c	 mov	 DWORD PTR [edi+44], eax

; 1249 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01594	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  01597	85 c0		 test	 eax, eax
  01599	75 05		 jne	 SHORT $LN1@inflate
  0159b	39 45 dc	 cmp	 DWORD PTR _out$1$[ebp], eax
  0159e	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  015a0	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  015a4	75 16		 jne	 SHORT $LN797@inflate
$LN2@inflate:
  015a6	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  015a9	5f		 pop	 edi
  015aa	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  015af	85 c0		 test	 eax, eax
  015b1	5e		 pop	 esi
  015b2	0f 44 c1	 cmove	 eax, ecx
  015b5	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  015b6	8b e5		 mov	 esp, ebp
  015b8	5d		 pop	 ebp
  015b9	c2 08 00	 ret	 8
$LN797@inflate:
  015bc	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  015bf	5f		 pop	 edi
  015c0	5e		 pop	 esi
  015c1	5b		 pop	 ebx
  015c2	8b e5		 mov	 esp, ebp
  015c4	5d		 pop	 ebp
  015c5	c2 08 00	 ret	 8
$LN498@inflate:

; 630  :         return Z_STREAM_ERROR;

  015c8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  015cd	8b e5		 mov	 esp, ebp
  015cf	5d		 pop	 ebp
  015d0	c2 08 00	 ret	 8
  015d3	90		 npad	 1
$LN837@inflate:
  015d4	00 00 00 00	 DD	 $LN489@inflate
  015d8	00 00 00 00	 DD	 $LN457@inflate
  015dc	00 00 00 00	 DD	 $LN437@inflate
  015e0	00 00 00 00	 DD	 $LN419@inflate
  015e4	00 00 00 00	 DD	 $LN402@inflate
  015e8	00 00 00 00	 DD	 $LN381@inflate
  015ec	00 00 00 00	 DD	 $LN374@inflate
  015f0	00 00 00 00	 DD	 $LN362@inflate
  015f4	00 00 00 00	 DD	 $LN350@inflate
  015f8	00 00 00 00	 DD	 $LN333@inflate
  015fc	00 00 00 00	 DD	 $LN321@inflate
  01600	00 00 00 00	 DD	 $LN316@inflate
  01604	00 00 00 00	 DD	 $LN315@inflate
  01608	00 00 00 00	 DD	 $LN282@inflate
  0160c	00 00 00 00	 DD	 $LN266@inflate
  01610	00 00 00 00	 DD	 $LN264@inflate
  01614	00 00 00 00	 DD	 $LN258@inflate
  01618	00 00 00 00	 DD	 $LN525@inflate
  0161c	00 00 00 00	 DD	 $LN528@inflate
  01620	00 00 00 00	 DD	 $LN148@inflate
  01624	00 00 00 00	 DD	 $LN146@inflate
  01628	00 00 00 00	 DD	 $LN113@inflate
  0162c	00 00 00 00	 DD	 $LN537@inflate
  01630	00 00 00 00	 DD	 $LN76@inflate
  01634	00 00 00 00	 DD	 $LN62@inflate
  01638	00 00 00 00	 DD	 $LN48@inflate
  0163c	00 00 00 00	 DD	 $LN46@inflate
  01640	00 00 00 00	 DD	 $LN30@inflate
  01644	00 00 00 00	 DD	 $LN15@inflate
  01648	00 00 00 00	 DD	 $LN14@inflate
  0164c	00 00 00 00	 DD	 $LN13@inflate
$LN838@inflate:
  01650	00 00 00 00	 DD	 $LN294@inflate
  01654	00 00 00 00	 DD	 $LN293@inflate
  01658	00 00 00 00	 DD	 $LN288@inflate
  0165c	00 00 00 00	 DD	 $LN287@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN1@inflateRes
  0000a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 1e		 je	 SHORT $LN1@inflateRes

; 135  :     state = (struct inflate_state FAR *)strm->state;
; 136  :     state->wsize = 0;

  00011	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 137  :     state->whave = 0;

  00018	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 138  :     state->wnext = 0;

  0001f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 139  :     return inflateResetKeep(strm);

  00026	89 45 08	 mov	 DWORD PTR _strm$[ebp], eax

; 140  : }

  00029	5d		 pop	 ebp

; 139  :     return inflateResetKeep(strm);

  0002a	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
$LN1@inflateRes:

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 140  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :     int ret;
; 187  :     struct inflate_state FAR *state;
; 188  : 
; 189  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 190  :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 a3 00 00
	00		 je	 $LN6@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 9a 00 00
	00		 jne	 $LN6@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 90 00 00
	00		 jne	 $LN6@inflateIni

; 192  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN5@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 220  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN5@inflateIni:

; 193  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 194  :     if (strm->zalloc == (alloc_func)0) {

  00031	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003c	75 0e		 jne	 SHORT $LN4@inflateIni

; 195  : #ifdef Z_SOLO
; 196  :         return Z_STREAM_ERROR;
; 197  : #else
; 198  :         strm->zalloc = zcalloc;

  0003e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 199  :         strm->opaque = (voidpf)0;

  00045	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN4@inflateIni:

; 200  : #endif
; 201  :     }
; 202  :     if (strm->zfree == (free_func)0)

  0004c	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00050	75 07		 jne	 SHORT $LN3@inflateIni

; 203  : #ifdef Z_SOLO
; 204  :         return Z_STREAM_ERROR;
; 205  : #else
; 206  :         strm->zfree = zcfree;

  00052	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN3@inflateIni:

; 207  : #endif
; 208  :     state = (struct inflate_state FAR *)
; 209  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	57		 push	 edi
  0005d	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00062	6a 01		 push	 1
  00064	ff 76 28	 push	 DWORD PTR [esi+40]
  00067	ff d0		 call	 eax
  00069	8b f8		 mov	 edi, eax
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	85 ff		 test	 edi, edi
  00070	75 09		 jne	 SHORT $LN2@inflateIni
  00072	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 220  : }

  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
$LN2@inflateIni:
  0007b	53		 push	 ebx

; 211  :     Tracev((stderr, "inflate: allocated\n"));
; 212  :     strm->state = (struct internal_state FAR *)state;
; 213  :     state->window = Z_NULL;
; 214  :     ret = inflateReset2(strm, windowBits);

  0007c	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00082	56		 push	 esi
  00083	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  0008a	e8 00 00 00 00	 call	 _inflateReset2@8
  0008f	8b d8		 mov	 ebx, eax

; 215  :     if (ret != Z_OK) {

  00091	85 db		 test	 ebx, ebx
  00093	74 13		 je	 SHORT $LN1@inflateIni

; 216  :         ZFREE(strm, state);

  00095	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00098	57		 push	 edi
  00099	ff 76 28	 push	 DWORD PTR [esi+40]
  0009c	ff d1		 call	 ecx
  0009e	83 c4 08	 add	 esp, 8

; 217  :         strm->state = Z_NULL;

  000a1	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN1@inflateIni:

; 218  :     }
; 219  :     return ret;

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 220  : }

  000ad	5d		 pop	 ebp
  000ae	c2 10 00	 ret	 16			; 00000010H
$LN6@inflateIni:

; 191  :         return Z_VERSION_ERROR;

  000b1	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 220  : }

  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 8d 00 00
	00		 je	 $LN2@inflateRes
  0000e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 82 00 00
	00		 je	 $LN2@inflateRes

; 110  :     state = (struct inflate_state FAR *)strm->state;
; 111  :     strm->total_in = strm->total_out = state->total = 0;

  00019	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00020	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 112  :     strm->msg = Z_NULL;

  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	85 d2		 test	 edx, edx
  0003a	74 06		 je	 SHORT $LN1@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  0003c	83 e2 01	 and	 edx, 1
  0003f	89 50 30	 mov	 DWORD PTR [eax+48], edx
$LN1@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->dmax = 32768U;
; 119  :     state->head = Z_NULL;
; 120  :     state->hold = 0;
; 121  :     state->bits = 0;
; 122  :     state->lencode = state->distcode = state->next = state->codes;

  00042	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00048	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  0004b	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  0004e	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00051	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00057	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00065	c7 41 14 00 80
	00 00		 mov	 DWORD PTR [ecx+20], 32768 ; 00008000H
  0006c	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00073	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0007a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 123  :     state->sane = 1;

  00081	c7 81 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7104], 1

; 124  :     state->back = -1;

  0008b	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 125  :     Tracev((stderr, "inflate: reset\n"));
; 126  :     return Z_OK;

  00095	33 c0		 xor	 eax, eax

; 127  : }

  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$LN2@inflateRes:

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0009b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 127  : }

  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 c0		 test	 eax, eax
  00009	74 73		 je	 SHORT $LN7@inflateRes
  0000b	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0000e	85 ff		 test	 edi, edi
  00010	74 6c		 je	 SHORT $LN7@inflateRes

; 151  :     state = (struct inflate_state FAR *)strm->state;
; 152  : 
; 153  :     /* extract wrap request from windowBits parameter */
; 154  :     if (windowBits < 0) {

  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN6@inflateRes

; 155  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 156  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 157  :     }
; 158  :     else {

  0001f	eb 0e		 jmp	 SHORT $LN4@inflateRes
$LN6@inflateRes:

; 159  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 160  : #ifdef GUNZIP
; 161  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN4@inflateRes

; 162  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN4@inflateRes:

; 163  : #endif
; 164  :     }
; 165  : 
; 166  :     /* set number of window bits, free window if different */
; 167  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 16		 je	 SHORT $LN3@inflateRes
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 05		 jl	 SHORT $LN2@inflateRes
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7e 0c		 jle	 SHORT $LN3@inflateRes
$LN2@inflateRes:
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 168  :         return Z_STREAM_ERROR;

  0003f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00044	5f		 pop	 edi

; 178  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN3@inflateRes:

; 169  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00049	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0004c	85 c9		 test	 ecx, ecx
  0004e	74 1b		 je	 SHORT $LN1@inflateRes
  00050	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00053	74 16		 je	 SHORT $LN1@inflateRes

; 170  :         ZFREE(strm, state->window);

  00055	51		 push	 ecx
  00056	ff 70 28	 push	 DWORD PTR [eax+40]
  00059	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0005c	ff d0		 call	 eax
  0005e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00061	83 c4 08	 add	 esp, 8

; 171  :         state->window = Z_NULL;

  00064	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN1@inflateRes:

; 172  :     }
; 173  : 
; 174  :     /* update state and reset the rest of it */
; 175  :     state->wrap = wrap;
; 176  :     state->wbits = (unsigned)windowBits;
; 177  :     return inflateReset(strm);

  0006b	50		 push	 eax
  0006c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0006f	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00072	e8 00 00 00 00	 call	 _inflateReset@4
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 178  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN7@inflateRes:

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00083	5f		 pop	 edi

; 178  : }

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 228  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 5c		 je	 SHORT $LN4@inflatePri
  0000a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 55		 je	 SHORT $LN4@inflatePri

; 238  :     state = (struct inflate_state FAR *)strm->state;
; 239  :     if (bits < 0) {

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	79 14		 jns	 SHORT $LN3@inflatePri

; 240  :         state->hold = 0;

  00018	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 241  :         state->bits = 0;

  0001f	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 242  :         return Z_OK;

  00026	33 c0		 xor	 eax, eax

; 249  : }

  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  0002c	56		 push	 esi
  0002d	57		 push	 edi

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0002e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00031	7f 28		 jg	 SHORT $LN1@inflatePri
  00033	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  00036	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00039	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003c	77 1d		 ja	 SHORT $LN1@inflatePri

; 245  :     value &= (1L << bits) - 1;

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	d3 e0		 shl	 eax, cl

; 246  :     state->hold += value << state->bits;

  00045	8b ce		 mov	 ecx, esi

; 247  :     state->bits += bits;

  00047	89 7a 3c	 mov	 DWORD PTR [edx+60], edi
  0004a	5f		 pop	 edi
  0004b	48		 dec	 eax
  0004c	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004f	5e		 pop	 esi
  00050	d3 e0		 shl	 eax, cl
  00052	01 42 38	 add	 DWORD PTR [edx+56], eax

; 248  :     return Z_OK;

  00055	33 c0		 xor	 eax, eax

; 249  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflatePri:
  0005b	5f		 pop	 edi

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00061	5e		 pop	 esi

; 249  : }

  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 249  : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 264  : #ifdef BUILDFIXED
; 265  :     static int virgin = 1;
; 266  :     static code *lenfix, *distfix;
; 267  :     static code fixed[544];
; 268  : 
; 269  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 270  :     if (virgin) {
; 271  :         unsigned sym, bits;
; 272  :         static code *next;
; 273  : 
; 274  :         /* literal/length table */
; 275  :         sym = 0;
; 276  :         while (sym < 144) state->lens[sym++] = 8;
; 277  :         while (sym < 256) state->lens[sym++] = 9;
; 278  :         while (sym < 280) state->lens[sym++] = 7;
; 279  :         while (sym < 288) state->lens[sym++] = 8;
; 280  :         next = fixed;
; 281  :         lenfix = next;
; 282  :         bits = 9;
; 283  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 284  : 
; 285  :         /* distance table */
; 286  :         sym = 0;
; 287  :         while (sym < 32) state->lens[sym++] = 5;
; 288  :         distfix = next;
; 289  :         bits = 5;
; 290  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 291  : 
; 292  :         /* do this just once */
; 293  :         virgin = 0;
; 294  :     }
; 295  : #else /* !BUILDFIXED */
; 296  : #   include "inffixed.h"
; 297  : #endif /* BUILDFIXED */
; 298  :     state->lencode = lenfix;

  00000	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 299  :     state->lenbits = 9;

  00007	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 300  :     state->distcode = distfix;

  0000e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 301  :     state->distbits = 5;

  00015	c7 41 58 05 00
	00 00		 mov	 DWORD PTR [ecx+88], 5

; 302  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c2		 mov	 eax, edx
  00006	8b d1		 mov	 edx, ecx
  00008	56		 push	 esi

; 384  :     struct inflate_state FAR *state;
; 385  :     unsigned dist;
; 386  : 
; 387  :     state = (struct inflate_state FAR *)strm->state;

  00009	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  0000c	57		 push	 edi

; 388  : 
; 389  :     /* if it hasn't been done already, allocate space for the window */
; 390  :     if (state->window == Z_NULL) {

  0000d	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  00011	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax
  00014	bf 01 00 00 00	 mov	 edi, 1
  00019	75 26		 jne	 SHORT $LN9@updatewind

; 391  :         state->window = (unsigned char FAR *)
; 392  :                         ZALLOC(strm, 1U << state->wbits,
; 393  :                                sizeof(unsigned char));

  0001b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0001e	8b c7		 mov	 eax, edi
  00020	d3 e0		 shl	 eax, cl
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 394  :         if (state->window == Z_NULL) return 1;

  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN13@updatewind
  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 427  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN13@updatewind:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN9@updatewind:

; 395  :     }
; 396  : 
; 397  :     /* if window not in use yet, initialize */
; 398  :     if (state->wsize == 0) {

  00041	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00045	75 16		 jne	 SHORT $LN8@updatewind

; 399  :         state->wsize = 1U << state->wbits;

  00047	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0004a	d3 e7		 shl	 edi, cl

; 400  :         state->wnext = 0;

  0004c	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 401  :         state->whave = 0;

  00053	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0005a	89 7e 28	 mov	 DWORD PTR [esi+40], edi
$LN8@updatewind:

; 402  :     }
; 403  : 
; 404  :     /* copy state->wsize or less output bytes into the circular window */
; 405  :     if (copy >= state->wsize) {

  0005d	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
  00060	53		 push	 ebx
  00061	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  00064	3b df		 cmp	 ebx, edi
  00066	72 25		 jb	 SHORT $LN7@updatewind

; 406  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00068	57		 push	 edi
  00069	2b c7		 sub	 eax, edi
  0006b	50		 push	 eax
  0006c	ff 76 34	 push	 DWORD PTR [esi+52]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 407  :         state->wnext = 0;
; 408  :         state->whave = state->wsize;

  00074	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  0007a	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0007d	5b		 pop	 ebx
  0007e	5f		 pop	 edi
  0007f	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 424  :         }
; 425  :     }
; 426  :     return 0;

  00086	33 c0		 xor	 eax, eax
  00088	5e		 pop	 esi

; 427  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN7@updatewind:

; 409  :     }
; 410  :     else {
; 411  :         dist = state->wsize - state->wnext;

  0008d	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 412  :         if (dist > copy) dist = copy;

  00090	3b fb		 cmp	 edi, ebx
  00092	0f 47 fb	 cmova	 edi, ebx

; 413  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00095	2b c3		 sub	 eax, ebx
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0009c	03 46 30	 add	 eax, DWORD PTR [esi+48]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  :         copy -= dist;

  000a8	2b df		 sub	 ebx, edi

; 415  :         if (copy) {

  000aa	74 24		 je	 SHORT $LN4@updatewind

; 416  :             zmemcpy(state->window, end - copy, copy);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000af	53		 push	 ebx
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 34	 push	 DWORD PTR [esi+52]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 417  :             state->wnext = copy;
; 418  :             state->whave = state->wsize;

  000bb	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  000c4	5b		 pop	 ebx

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000c5	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000c8	5f		 pop	 edi

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5e		 pop	 esi

; 427  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN4@updatewind:

; 419  :         }
; 420  :         else {
; 421  :             state->wnext += dist;

  000d0	01 7e 30	 add	 DWORD PTR [esi+48], edi

; 422  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d3	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000d6	33 d2		 xor	 edx, edx
  000d8	3b 46 28	 cmp	 eax, DWORD PTR [esi+40]
  000db	0f 44 c2	 cmove	 eax, edx
  000de	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000e1	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000e4	3b 46 28	 cmp	 eax, DWORD PTR [esi+40]
  000e7	73 05		 jae	 SHORT $LN1@updatewind
  000e9	03 c7		 add	 eax, edi
  000eb	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN1@updatewind:

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000ee	5b		 pop	 ebx
  000ef	5f		 pop	 edi
  000f0	33 c0		 xor	 eax, eax
  000f2	5e		 pop	 esi

; 427  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1272 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 52		 je	 SHORT $LN3@inflateGet
  0000b	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  0000e	85 f6		 test	 esi, esi
  00010	74 4b		 je	 SHORT $LN3@inflateGet

; 1277 :     state = (struct inflate_state FAR *)strm->state;
; 1278 : 
; 1279 :     /* copy dictionary */
; 1280 :     if (state->whave && dictionary != Z_NULL) {

  00012	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00015	85 c0		 test	 eax, eax
  00017	74 31		 je	 SHORT $LN2@inflateGet
  00019	57		 push	 edi
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  0001d	85 ff		 test	 edi, edi
  0001f	74 28		 je	 SHORT $LN7@inflateGet

; 1281 :         zmemcpy(dictionary, state->window + state->wnext,
; 1282 :                 state->whave - state->wnext);

  00021	2b 46 30	 sub	 eax, DWORD PTR [esi+48]
  00024	50		 push	 eax
  00025	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00028	03 46 30	 add	 eax, DWORD PTR [esi+48]
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _memcpy

; 1283 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1284 :                 state->window, state->wnext);

  00032	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00035	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00038	51		 push	 ecx
  00039	ff 76 34	 push	 DWORD PTR [esi+52]
  0003c	2b c1		 sub	 eax, ecx
  0003e	03 c7		 add	 eax, edi
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _memcpy
  00046	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@inflateGet:
  00049	5f		 pop	 edi
$LN2@inflateGet:

; 1285 :     }
; 1286 :     if (dictLength != Z_NULL)

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 05		 je	 SHORT $LN1@inflateGet

; 1287 :         *dictLength = state->whave;

  00051	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00054	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@inflateGet:

; 1288 :     return Z_OK;

  00056	33 c0		 xor	 eax, eax
  00058	5e		 pop	 esi

; 1289 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateGet:

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0005d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00062	5e		 pop	 esi

; 1289 : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	0f 84 84 00 00
	00		 je	 $LN5@inflateSet
  00010	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00013	85 f6		 test	 esi, esi
  00015	74 7d		 je	 SHORT $LN5@inflateSet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if (state->wrap != 0 && state->mode != DICT)

  00017	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001b	53		 push	 ebx
  0001c	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  0001f	74 11		 je	 SHORT $LN4@inflateSet
  00021	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00024	74 11		 je	 SHORT $LN9@inflateSet

; 1304 :         return Z_STREAM_ERROR;

  00026	5b		 pop	 ebx
  00027	5f		 pop	 edi
  00028	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002d	5e		 pop	 esi

; 1324 : }

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflateSet:

; 1305 : 
; 1306 :     /* check for correct dictionary identifier */
; 1307 :     if (state->mode == DICT) {

  00032	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00035	75 26		 jne	 SHORT $LN2@inflateSet
$LN9@inflateSet:

; 1308 :         dictid = adler32(0L, Z_NULL, 0);
; 1309 :         dictid = adler32(dictid, dictionary, dictLength);

  00037	53		 push	 ebx
  00038	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 _adler32@12
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _adler32@12

; 1310 :         if (dictid != state->check)

  0004c	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0004f	74 0c		 je	 SHORT $LN2@inflateSet

; 1311 :             return Z_DATA_ERROR;

  00051	5b		 pop	 ebx
  00052	5f		 pop	 edi
  00053	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00058	5e		 pop	 esi

; 1324 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateSet:

; 1312 :     }
; 1313 : 
; 1314 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1315 :        existing dictionary if appropriate */
; 1316 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  00060	53		 push	 ebx
  00061	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 _updatewindow
  0006b	83 c4 04	 add	 esp, 4

; 1317 :     if (ret) {

  0006e	85 c0		 test	 eax, eax
  00070	74 12		 je	 SHORT $LN1@inflateSet

; 1318 :         state->mode = MEM;

  00072	5b		 pop	 ebx
  00073	5f		 pop	 edi
  00074	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH

; 1319 :         return Z_MEM_ERROR;

  0007a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007f	5e		 pop	 esi

; 1324 : }

  00080	5d		 pop	 ebp
  00081	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflateSet:
  00084	5b		 pop	 ebx
  00085	5f		 pop	 edi

; 1320 :     }
; 1321 :     state->havedict = 1;

  00086	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1322 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1323 :     return Z_OK;

  0008d	33 c0		 xor	 eax, eax
  0008f	5e		 pop	 esi

; 1324 : }

  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:
  00094	5f		 pop	 edi

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00095	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0009a	5e		 pop	 esi

; 1324 : }

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 20		 je	 SHORT $LN2@inflateGet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 19		 je	 SHORT $LN2@inflateGet

; 1334 :     state = (struct inflate_state FAR *)strm->state;
; 1335 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 41 08 02	 test	 BYTE PTR [ecx+8], 2
  00015	74 13		 je	 SHORT $LN2@inflateGet

; 1336 : 
; 1337 :     /* save header structure */
; 1338 :     state->head = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1339 :     head->done = 0;

  0001d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1340 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1341 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN2@inflateGet:

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1341 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1359 :     unsigned got;
; 1360 :     unsigned next;
; 1361 : 
; 1362 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1363 :     next = 0;
; 1364 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 51		 je	 SHORT $LN12@syncsearch
  00019	53		 push	 ebx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL6@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 37		 jae	 SHORT $LN13@syncsearch

; 1365 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	1b d2		 sbb	 edx, edx
  0002d	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00033	0f b6 cb	 movzx	 ecx, bl
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1366 :             got++;

  00040	40		 inc	 eax
  00041	eb 11		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1367 :         else if (buf[next])

  00043	84 db		 test	 bl, bl
  00045	74 04		 je	 SHORT $LN2@syncsearch

; 1368 :             got = 0;

  00047	33 c0		 xor	 eax, eax

; 1369 :         else

  00049	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1370 :             got = 4 - got;

  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	2b c8		 sub	 ecx, eax
  00052	8b c1		 mov	 eax, ecx
$LN1@syncsearch:

; 1371 :         next++;

  00054	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00057	46		 inc	 esi
  00058	3b f7		 cmp	 esi, edi
  0005a	72 c4		 jb	 SHORT $LL6@syncsearch
$LN13@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005f	5b		 pop	 ebx
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	5f		 pop	 edi

; 1374 :     return next;

  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 1375 : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN12@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  0006a	89 01		 mov	 DWORD PTR [ecx], eax
  0006c	5f		 pop	 edi

; 1374 :     return next;

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1375 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 cf 00 00
	00		 je	 $LN6@inflateSyn
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 c4 00 00
	00		 je	 $LN6@inflateSyn

; 1387 :     state = (struct inflate_state FAR *)strm->state;
; 1388 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 11		 jne	 SHORT $LN5@inflateSyn
  00021	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00025	73 0b		 jae	 SHORT $LN5@inflateSyn
  00027	5f		 pop	 edi
  00028	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0002d	5b		 pop	 ebx

; 1418 : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1389 : 
; 1390 :     /* if first time, start search in bit buffer */
; 1391 :     if (state->mode != SYNC) {

  00032	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00035	56		 push	 esi
  00036	74 56		 je	 SHORT $LN4@inflateSyn

; 1392 :         state->mode = SYNC;
; 1393 :         state->hold <<= state->bits & 7;

  00038	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  0003b	8b ca		 mov	 ecx, edx
  0003d	83 e1 07	 and	 ecx, 7
  00040	d3 67 38	 shl	 DWORD PTR [edi+56], cl

; 1394 :         state->bits -= state->bits & 7;

  00043	2b d1		 sub	 edx, ecx

; 1395 :         len = 0;

  00045	33 f6		 xor	 esi, esi
  00047	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  0004d	89 57 3c	 mov	 DWORD PTR [edi+60], edx

; 1396 :         while (state->bits >= 8) {

  00050	83 fa 08	 cmp	 edx, 8
  00053	72 24		 jb	 SHORT $LN2@inflateSyn
  00055	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@inflateSyn:

; 1397 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 47 38	 mov	 al, BYTE PTR [edi+56]
  00063	88 44 35 08	 mov	 BYTE PTR _buf$[ebp+esi], al

; 1398 :             state->hold >>= 8;

  00067	c1 e9 08	 shr	 ecx, 8

; 1399 :             state->bits -= 8;

  0006a	83 ea 08	 sub	 edx, 8
  0006d	46		 inc	 esi
  0006e	89 4f 38	 mov	 DWORD PTR [edi+56], ecx
  00071	83 fa 08	 cmp	 edx, 8
  00074	73 ea		 jae	 SHORT $LL3@inflateSyn
  00076	89 57 3c	 mov	 DWORD PTR [edi+60], edx
$LN2@inflateSyn:

; 1400 :         }
; 1401 :         state->have = 0;

  00079	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]

; 1402 :         syncsearch(&(state->have), buf, len);

  0007c	56		 push	 esi
  0007d	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  00080	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00086	e8 00 00 00 00	 call	 _syncsearch
  0008b	83 c4 04	 add	 esp, 4
$LN4@inflateSyn:

; 1403 :     }
; 1404 : 
; 1405 :     /* search available input */
; 1406 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0008e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00091	8b 13		 mov	 edx, DWORD PTR [ebx]
  00093	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00096	e8 00 00 00 00	 call	 _syncsearch

; 1407 :     strm->avail_in -= len;

  0009b	29 43 04	 sub	 DWORD PTR [ebx+4], eax

; 1408 :     strm->next_in += len;

  0009e	01 03		 add	 DWORD PTR [ebx], eax

; 1409 :     strm->total_in += len;

  000a0	01 43 08	 add	 DWORD PTR [ebx+8], eax
  000a3	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000a6	83 c4 04	 add	 esp, 4

; 1410 : 
; 1411 :     /* return no joy or set up to restart inflate() on a new block */
; 1412 :     if (state->have != 4) return Z_DATA_ERROR;

  000a9	83 7f 68 04	 cmp	 DWORD PTR [edi+104], 4
  000ad	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000b0	74 0c		 je	 SHORT $LN1@inflateSyn
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi
  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	5b		 pop	 ebx

; 1418 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN1@inflateSyn:

; 1413 :     in = strm->total_in;  out = strm->total_out;

  000be	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1414 :     inflateReset(strm);

  000c1	53		 push	 ebx
  000c2	e8 00 00 00 00	 call	 _inflateReset@4

; 1415 :     strm->total_in = in;  strm->total_out = out;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000ca	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000cd	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000d0	5e		 pop	 esi

; 1416 :     state->mode = TYPE;

  000d1	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000d7	5f		 pop	 edi

; 1417 :     return Z_OK;

  000d8	33 c0		 xor	 eax, eax
  000da	5b		 pop	 ebx

; 1418 : }

  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN6@inflateSyn:
  000df	5f		 pop	 edi

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e0	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e5	5b		 pop	 ebx

; 1418 : }

  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN1@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 1a		 je	 SHORT $LN1@inflateSyn

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0f		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 09		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1436 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00025	33 c0		 xor	 eax, eax

; 1436 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN1@inflateSyn:

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1436 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_copy$1$ = -4						; size = 4
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1442 :     struct inflate_state FAR *state;
; 1443 :     struct inflate_state FAR *copy;
; 1444 :     unsigned char FAR *window;
; 1445 :     unsigned wsize;
; 1446 : 
; 1447 :     /* check input */
; 1448 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1449 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	0f 84 35 01 00
	00		 je	 $LN6@inflateCop
  00010	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 2a 01 00
	00		 je	 $LN6@inflateCop
  0001b	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0001e	85 db		 test	 ebx, ebx
  00020	0f 84 1f 01 00
	00		 je	 $LN6@inflateCop
  00026	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 14 01 00
	00		 je	 $LN6@inflateCop
  00031	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00035	0f 84 0a 01 00
	00		 je	 $LN6@inflateCop

; 1451 :     state = (struct inflate_state FAR *)source->state;
; 1452 : 
; 1453 :     /* allocate space */
; 1454 :     copy = (struct inflate_state FAR *)
; 1455 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0003b	57		 push	 edi
  0003c	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00041	6a 01		 push	 1
  00043	ff 76 28	 push	 DWORD PTR [esi+40]
  00046	ff d0		 call	 eax
  00048	8b f8		 mov	 edi, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	89 7d fc	 mov	 DWORD PTR _copy$1$[ebp], edi

; 1456 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00050	85 ff		 test	 edi, edi
  00052	74 38		 je	 SHORT $LN11@inflateCop

; 1457 :     window = Z_NULL;
; 1458 :     if (state->window != Z_NULL) {

  00054	83 7b 34 00	 cmp	 DWORD PTR [ebx+52], 0
  00058	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0005f	74 39		 je	 SHORT $LN3@inflateCop

; 1459 :         window = (unsigned char FAR *)
; 1460 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  00061	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	d3 e0		 shl	 eax, cl
  0006b	6a 01		 push	 1
  0006d	50		 push	 eax
  0006e	ff 76 28	 push	 DWORD PTR [esi+40]
  00071	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00074	ff d0		 call	 eax
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1461 :         if (window == Z_NULL) {

  0007c	85 c0		 test	 eax, eax
  0007e	75 1a		 jne	 SHORT $LN3@inflateCop

; 1462 :             ZFREE(source, copy);

  00080	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00083	57		 push	 edi
  00084	ff 76 28	 push	 DWORD PTR [esi+40]
  00087	ff d0		 call	 eax
  00089	83 c4 08	 add	 esp, 8
$LN11@inflateCop:

; 1463 :             return Z_MEM_ERROR;

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00093	5b		 pop	 ebx

; 1483 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1464 :         }
; 1465 :     }
; 1466 : 
; 1467 :     /* copy state */
; 1468 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0009a	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
  0009d	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH

; 1469 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000a2	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000a7	f3 a5		 rep movsd
  000a9	8b 75 fc	 mov	 esi, DWORD PTR _copy$1$[ebp]
  000ac	53		 push	 ebx
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 _memcpy

; 1470 :     if (state->lencode >= state->codes &&
; 1471 :         state->lencode <= state->codes + ENOUGH - 1) {

  000b3	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000b6	8d 83 30 05 00
	00		 lea	 eax, DWORD PTR [ebx+1328]
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	3b c8		 cmp	 ecx, eax
  000c1	72 38		 jb	 SHORT $LN2@inflateCop
  000c3	8d 83 bc 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7100]
  000c9	3b c8		 cmp	 ecx, eax
  000cb	77 2e		 ja	 SHORT $LN2@inflateCop

; 1472 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000cd	2b cb		 sub	 ecx, ebx
  000cf	8d 81 d0 fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1328]
  000d5	c1 f8 02	 sar	 eax, 2
  000d8	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000dd	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e0	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 1473 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e3	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  000e6	2b c3		 sub	 eax, ebx
  000e8	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  000ed	c1 f8 02	 sar	 eax, 2
  000f0	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000f5	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f8	89 46 50	 mov	 DWORD PTR [esi+80], eax
$LN2@inflateCop:

; 1474 :     }
; 1475 :     copy->next = copy->codes + (state->next - state->codes);

  000fb	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]

; 1476 :     if (window != Z_NULL) {

  000fe	8b 7d 0c	 mov	 edi, DWORD PTR _window$1$[ebp]
  00101	2b c3		 sub	 eax, ebx
  00103	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00108	c1 f8 02	 sar	 eax, 2
  0010b	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00110	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00113	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00116	85 ff		 test	 edi, edi
  00118	74 17		 je	 SHORT $LN1@inflateCop

; 1477 :         wsize = 1U << state->wbits;

  0011a	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	d3 e0		 shl	 eax, cl

; 1478 :         zmemcpy(window, state->window, wsize);

  00124	50		 push	 eax
  00125	ff 73 34	 push	 DWORD PTR [ebx+52]
  00128	57		 push	 edi
  00129	e8 00 00 00 00	 call	 _memcpy
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1479 :     }
; 1480 :     copy->window = window;
; 1481 :     dest->state = (struct internal_state FAR *)copy;

  00131	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00134	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  00137	5f		 pop	 edi
  00138	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  0013b	5e		 pop	 esi

; 1482 :     return Z_OK;

  0013c	33 c0		 xor	 eax, eax
  0013e	5b		 pop	 ebx

; 1483 : }

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 08 00	 ret	 8
$LN6@inflateCop:
  00145	5e		 pop	 esi

; 1450 :         return Z_STREAM_ERROR;

  00146	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0014b	5b		 pop	 ebx

; 1483 : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN1@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 13		 je	 SHORT $LN1@inflateUnd

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     state->sane = !subvert;
; 1494 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1495 :     return Z_OK;
; 1496 : #else
; 1497 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1498 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1499 : #endif
; 1500 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN1@inflateUnd:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1499 : #endif
; 1500 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4e		 je	 SHORT $LN1@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 47		 je	 SHORT $LN1@inflateMar

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 12		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1512 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN7@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  0002a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002d	75 18		 jne	 SHORT $LN5@inflateMar
  0002f	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00035	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00038	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	03 c1		 add	 eax, ecx

; 1512 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00047	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1512 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN1@inflateMar:

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00058	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1512 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
END
