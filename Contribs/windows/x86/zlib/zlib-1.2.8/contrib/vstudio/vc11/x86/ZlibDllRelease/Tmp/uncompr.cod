; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Trunk2012\Contribs\windows\x86\zlib\zlib-1.2.8\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress@16
; Function compile flags: /Ogtp
; File c:\trunk2012\contribs\windows\x86\zlib\zlib-1.2.8\uncompr.c
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H

; 30   :     z_stream stream;
; 31   :     int err;
; 32   : 
; 33   :     stream.next_in = (z_const Bytef *)source;

  00009	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]
  0000c	89 04 24	 mov	 DWORD PTR _stream$[esp+56], eax

; 34   :     stream.avail_in = (uInt)sourceLen;

  0000f	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00012	56		 push	 esi
  00013	57		 push	 edi

; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : 
; 38   :     stream.next_out = dest;
; 39   :     stream.avail_out = (uInt)*destLen;

  00014	8b 7d 0c	 mov	 edi, DWORD PTR _destLen$[ebp]
  00017	89 44 24 0c	 mov	 DWORD PTR _stream$[esp+68], eax
  0001b	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0001e	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax
  00022	8b 07		 mov	 eax, DWORD PTR [edi]

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;
; 43   :     stream.zfree = (free_func)0;
; 44   : 
; 45   :     err = inflateInit(&stream);

  00024	6a 38		 push	 56			; 00000038H
  00026	89 44 24 1c	 mov	 DWORD PTR _stream$[esp+84], eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  0002f	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  00033	50		 push	 eax
  00034	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+108], 0
  0003c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+112], 0
  00044	e8 00 00 00 00	 call	 _inflateInit_@12

; 46   :     if (err != Z_OK) return err;

  00049	85 c0		 test	 eax, eax
  0004b	75 55		 jne	 SHORT $LN7@uncompress

; 47   : 
; 48   :     err = inflate(&stream, Z_FINISH);

  0004d	6a 04		 push	 4
  0004f	8d 44 24 0c	 lea	 eax, DWORD PTR _stream$[esp+68]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _inflate@8
  00059	8b f0		 mov	 esi, eax

; 49   :     if (err != Z_STREAM_END) {

  0005b	83 fe 01	 cmp	 esi, 1
  0005e	74 32		 je	 SHORT $LN3@uncompress

; 50   :         inflateEnd(&stream);

  00060	8d 44 24 08	 lea	 eax, DWORD PTR _stream$[esp+64]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _inflateEnd@4

; 51   :         if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))

  0006a	83 fe 02	 cmp	 esi, 2
  0006d	74 16		 je	 SHORT $LN1@uncompress
  0006f	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00072	75 07		 jne	 SHORT $LN2@uncompress
  00074	83 7c 24 0c 00	 cmp	 DWORD PTR _stream$[esp+68], 0
  00079	74 0a		 je	 SHORT $LN1@uncompress
$LN2@uncompress:

; 53   :         return err;

  0007b	8b c6		 mov	 eax, esi

; 58   :     return err;
; 59   : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
$LN1@uncompress:

; 52   :             return Z_DATA_ERROR;

  00085	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 58   :     return err;
; 59   : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 10 00	 ret	 16			; 00000010H
$LN3@uncompress:

; 54   :     }
; 55   :     *destLen = stream.total_out;

  00092	8b 44 24 1c	 mov	 eax, DWORD PTR _stream$[esp+84]
  00096	89 07		 mov	 DWORD PTR [edi], eax

; 56   : 
; 57   :     err = inflateEnd(&stream);

  00098	8d 44 24 08	 lea	 eax, DWORD PTR _stream$[esp+64]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _inflateEnd@4
$LN7@uncompress:

; 58   :     return err;
; 59   : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
_TEXT	ENDS
END
